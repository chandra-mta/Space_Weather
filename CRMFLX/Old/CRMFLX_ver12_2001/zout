2,4c2,4
<      $        FSWIMN,FSWI95,FSWI50,FSWISD,IUSEMSH,SMOOTH1,NFLXGET,
<      $        NDROPHI,NDROPLO,LOGFLG,RNGTOL,FPCHI,FPCLO,IDLOC,FLUXMN,
<      $        FLUX95,FLUX50,FLUXSD)
---
>      $   FSWIMN,FSWI95,FSWI50,FSWISD,IUSEMSH,IUSEMSP,SMOOTH1,NFLXGET,
>      $   NDROPHI,NDROPLO,LOGFLG,RNGTOL,FPCHI,FPCLO,IDLOC,FLUXMN,
>      $   FLUX95,FLUX50,FLUXSD)
14c14
< C       13 Sept. 2000 -> changed CRMFLX`s interface so that the data
---
> C       13 Sept. 2000 -> changed CRMFLX's interface so that the data
20c20
< C       13 Sept. 2000 -> changed CRMFLX`s interface so that the user
---
> C       13 Sept. 2000 -> changed CRMFLX's interface so that the user
32c32
< C                            to CRMFLX`s interface.
---
> C                            to CRMFLX's interface.
48a49,69
> C
> C       CRMFLX_V20_EXP created summer of 2002.
> C
> C
> C       CRMFLX_V21_EXP modifications.
> C       30 Jul 2002   -> changed near-neighbor flux search algorithm
> C                        to speed up magnetosphere calculations.
> C
> C       CRMFLX_V22_EXP modifications.
> C       30 Aug 2002   -> added IUSEMSP flag to interface.
> C                     -> changed smoothing algorithms so that there is
> C                        no spatial averaging across the ring current
> C                        region with flux values outside 8 Re.
> C                     -> implemented Kp scaling of flux values.
> C
> C       CRMFLX_V23_EXP modifications.
> C       22 Nov 2002   -> placed output from subroutine MSPINIT under a
> C                        SAVE statement.  This ensures that the content
> C                        of these variables is not lost from one call to
> C                        CRMFLX to the next.
> C                        
59c80
< C       LUNIT   - Array of unit numbers used in opening CRM`s database
---
> C       LUNIT   - Array of unit numbers used in opening CRM's database
67c88
< C       XGSM    - satellite`s X-coordinate (Re).
---
> C       XGSM    - satellite's X-coordinate (Re).
69c90
< C       YGSM    - satellite`s Y-coordinate (Re).
---
> C       YGSM    - satellite's Y-coordinate (Re).
71c92
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       ZGSM    - satellite's Z-coordinate (Re).
107a129,135
> C       IUSEMSP - flag for control of magnetosphere flux calculation:
> C          IUSEMSP = 0 if only the magnetosphere model flux is used.
> C          IUSEMSP = 1 if user supplied uniform solar wind flux value
> C                      is added to the magnetosphere flux.
> C          IUSEMSP = 2 if analytic solar wind model (uniform flux) is
> C                      added to the magnetosphere flux.
> C
169a198
>       INCLUDE 'MAXNUM.PAR'
170a200
>       INCLUDE 'MAXNSPHVOL.PAR'
194a225,227
>       INTEGER IOFFSET3(MAXNSPHVOL),JOFFSET3(MAXNSPHVOL)
>       INTEGER KOFFSET3(MAXNSPHVOL),IMAPINDX3(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
210c243,246
<      $ SC503,SCSIG3,NSECTR1,NSECTR2,NSECTR3
---
>      $ SC503,SCSIG3,NSECTR1,NSECTR2,NSECTR3,NSPHVOL3,IOFFSET3,JOFFSET3,
>      $ KOFFSET3,IMAPINDX3
> C
>       
231c267,270
<         CALL MSPINIT(LUNIT(3),ISPECI)
---
>         CALL MSPINIT(LUNIT(3),ISPECI,NSPHVOL3,IOFFSET3,JOFFSET3,
>      $               KOFFSET3,IMAPINDX3)
> D       WRITE(*,*)' After MSPINIT! '
> D       PAUSE 'PAUSED!'
235c274
< C     spacecraft`s coordinates are returned after transformation into
---
> C     spacecraft's coordinates are returned after transformation into
241c280
< D     PAUSE
---
> D     PAUSE 'PAUSED!'
261c300
< C         Use the user`s value for the uniform solar wind flux.
---
> C         Use the user's value for the uniform solar wind flux.
278c317
< C         Calculate the solar wind`s flux for this Kp value & position.
---
> C         Calculate the solar wind's flux for this Kp value & position.
284c323
< C           Add the user`s solar wind flux to this database model`s
---
> C           Add the user's solar wind flux to this database model's
292c331
< C         Add the user`s solar wind flux to the simple (uniform flux)
---
> C         Add the user's solar wind flux to the simple (uniform flux)
324c363
< C         Scale the user`s value for the uniform solar wind flux for
---
> C         Scale the user's value for the uniform solar wind flux for
326c365
< C         to use is just simply multiply the user`s solar wind flux
---
> C         to use is just simply multiply the user's solar wind flux
345,346c384
< C         Calculate the solar wind`s flux for this Kp value & position.
< 
---
> C         Calculate the solar wind's flux for this Kp value & position.
351d388
< c         write(*,*) "I AM HERE: ", fluxmn,flux95,flux50,fluxsd
353,354c390,391
< C           Add the user`s scaled solar wind flux to the database
< C           model`s flux predictions.
---
> C           Add the user's scaled solar wind flux to the database
> C           model's flux predictions.
361c398
< C         Add the user`s solar wind flux to the simple (uniform flux)
---
> C         Add the user's solar wind flux to the simple (uniform flux)
377a415,420
> C       Avoid the XKP = 0 value.
>         IF(XKP.LE.-1.5) THEN
>           XKP3 = 1.5
>         ELSE
>           XKP3 = XKP
>         END IF
380c423
<         XKPDIFF = ABS(XKP - XKPSAV3)
---
>         XKPDIFF = ABS(XKP3 - XKPSAV3)
383c426
<           CALL SCALKP3(XKP,ISPECI,NSECTR3,SECTX3,SECTY3,SCMEAN3,SC953,
---
>           CALL SCALKP3(XKP3,ISPECI,NSECTR3,SECTX3,SECTY3,SCMEAN3,SC953,
385c428
<           XKPSAV3 = XKP
---
>           XKPSAV3 = XKP3
388,392c431,465
< C       Calculate the magnetosphere`s flux for this Kp value & position.
<         CALL NBRFLUX(XKP,NSECTR3,SECTX3,SECTY3,SCMEAN3,SC953,SC503,
<      $    SCSIG3,XTAIL,YTAIL,ZTAIL,NUMDAT3,XFLUX3,YFLUX3,ZFLUX3,FLXBIN3,
<      $    NUMBIN3,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,LOGFLG,RNGTOL,FPCHI,
<      $    FPCLO,FLUXMN,FLUX95,FLUX50,FLUXSD)
---
> D       WRITE(*,*)' XKP,XKP3,XKPSAV3 = ',XKP,XKP3,XKPSAV3
> D       WRITE(*,*)' ISPSAV3,XKPDIFF,ISPDIFF = ',ISPSAV3,XKPDIFF,ISPDIFF
> C       Calculate the magnetosphere's flux for this Kp value & position.
>           CALL NBRFLUX_MAP_Z(XKP3,NSECTR3,SECTX3,SECTY3,SCMEAN3,SC953,
>      $      SC503,SCSIG3,XTAIL,YTAIL,ZTAIL,NUMDAT3,XFLUX3,YFLUX3,ZFLUX3,
>      $      FLXBIN3,NUMBIN3,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,LOGFLG,
>      $      RNGTOL,FPCHI,FPCLO,NSPHVOL3,IOFFSET3,JOFFSET3,KOFFSET3,
>      $      IMAPINDX3,FLUXMN,FLUX95,FLUX50,FLUXSD)
> C
> CC      CALL NBRFLUX(XKP3,NSECTR3,SECTX3,SECTY3,SCMEAN3,SC953,SC503,
> CC   $      SCSIG3,XTAIL,YTAIL,ZTAIL,NUMDAT3,XFLUX3,YFLUX3,ZFLUX3,
> CC   $      FLXBIN3,NUMBIN3,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,LOGFLG,
> CC   $      RNGTOL,FPCHI,FPCLO,FLUXMN,FLUX95,FLUX50,FLUXSD)
> D       WRITE(*,*)
> D       WRITE(*,*)' Before: FLUXMN,FLUX95,FLUX50,FLUXSD = ',
> D    $                      FLUXMN,FLUX95,FLUX50,FLUXSD
> D       WRITE(*,*)'         FSWIMN,FLUX95,FSWI50,FSWISD = ',
> D    $                      FSWIMN,FLUX95,FSWI50,FSWISD
> C
>         IF(IUSEMSP.EQ.1) THEN
> C         Add 1/2 of the user supplied uniform solar wind flux values
> C         to the calculated magnetospheric flux values.
>           FLUXMN = FLUXMN + FSWIMN * 0.5
>           FLUX95 = FLUX95 + FSWI95 * 0.5
>           FLUX50 = FLUX50 + FSWI50 * 0.5
>           FLUXSD = FLUXSD + FSWISD * 0.5
>         ELSE IF(IUSEMSP.EQ.2) THEN
> C         Add 1/2 of the analytic solar wind model's uniform flux values
> C         to the calculated magnetospheric flux values.
>           CALL SOLWFLX(XKP,ISPECI,FLXMNSW,FLX95SW,FLX50SW,FLXSDSW)
>           FLUXMN = FLUXMN + FLXMNSW * 0.5
>           FLUX95 = FLUX95 + FLX95SW * 0.5
>           FLUX50 = FLUX50 + FLX50SW * 0.5
>           FLUXSD = FLUXSD + FLXSDSW * 0.5
>         END IF
400a474
> D     PAUSE 'PAUSED!'
416c490
< C     "A Model of the Earth`s Distant Bow Shock."  This paper was
---
> C     "A Model of the Earth's Distant Bow Shock."  This paper was
592c666,667
<       SUBROUTINE MSPINIT(LUNIT,ISPECI)
---
>       SUBROUTINE MSPINIT(LUNIT,ISPECI,NSPHVOL3,IOFFSET3,JOFFSET3,
>      $  KOFFSET3,IMAPINDX3)
597,602c672,677
< C     Input:
< C       LUNIT   - unit number used in opening CRM`s database.
< C       ISPECI  - ion species selection flag
< C                 ISPECI = 1 for protons
< C                 ISPECI = 2 for Helium
< C                 ISPECI = 3 for CNO
---
> C     Inputs:
> C       LUNIT     - unit number used in opening CRM's database.
> C       ISPECI    - ion species selection flag
> C                    ISPECI = 1 for protons
> C                    ISPECI = 2 for Helium
> C                    ISPECI = 3 for CNO
604c679,686
<       INCLUDE 'MAXPNT.PAR'
---
> C     Outputs:
> C       NSPHVOL3  - number of volume elements stored in search volume.
> C       IOFFSET3  - array of offset indices for X-direction.
> C       JOFFSET3  - array of offset indices for Y-direction.
> C       KOFFSET3  - array of offset indices for Z-direction.
> C       IMAPINDX3 - array of pointers to flux database.
> C
>       INCLUDE 'MAXNUM.PAR'
605a688,696
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
> C     MAXNSPHVOL - maximum number of volume elements stored in the
> C                  mapped database.
>       INCLUDE 'MAXNSPHVOL.PAR'
> C
>       INTEGER IOFFSET3(MAXNSPHVOL),JOFFSET3(MAXNSPHVOL)
>       INTEGER KOFFSET3(MAXNSPHVOL),IMAPINDX3(MAXKP,MAXNUM,MAXNUM,MAXNUM)
609a701
>       LOGICAL FIRST
617a710,711
>       FIRST = .TRUE.
> C
620,622c714,717
<         OPEN(LUNIT,FILE='/data/mta4/proj/rac/ops/CRM/v1.21/crmflx_v1.2_2&
<      &5jan2001/MSPH_Kp_PROT.BIN',
< c    &5jan2001/MSPH_Kp_PROTDASC',
---
>         OPEN(LUNIT,FILE=
>      $  '/data/mta4/proj/rac/ops/CRM2/v26apr2004/crmflx_v23/MSPH_Kp_PROT&
>      &.BIN',
> C    &.ASC',
644,646c739,753
<       WRITE(*,*)
<       WRITE(*,*)' Read CRMFLX magnetosphere data file.'
<       WRITE(*,*)
---
> C     Initialize the flux pointer database to negative values to
> C     indicate that the cells are empty.
>       DO IIKP = 1,MAXKP
>         DO IIX = 1,MAXNUM
>           DO IIY = 1,MAXNUM
>             DO IIZ = 1,MAXNUM
>               IMAPINDX3(IIKP,IIX,IIY,IIZ) = -9999
>             END DO
>           END DO
>         END DO
>       END DO
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' Read CRMFLX magnetosphere data file.'
> D     WRITE(*,*)
671a779
>             IMAPINDX3(KK,I,J,K) = NUMDAT3(KK)
698a807,815
> C
> C     Get the (I,J,K) index offset values used to search for the
> C     near-neighbor flux.
> C
> C     Set the maximum distance (Re) to search for a near-neighbor.
>       DISTMAPMAX3 = 20.
>       CALL MAPSPHERE(DISTMAPMAX3,XINC,YINC,ZINC,NSPHVOL3,
>      $  IOFFSET3,JOFFSET3,KOFFSET3)
> C
711c828
< C       LUNIT   - unit number used in opening CRM`s database.
---
> C       LUNIT   - unit number used in opening CRM's database.
728,730c845,848
<         OPEN(LUNIT,FILE='/data/mta4/proj/rac/ops/CRM/v1.21/crmflx_v1.2_2&
<      &5jan2001/MSheath_Kp_PROT.BIN',
< c    &5jan2001/MSheath_Kp_PROT.ASC',
---
>         OPEN(LUNIT,FILE=
>      $  '/data/mta4/proj/rac/ops/CRM2/v26apr2004/crmflx_v23/MSheath_Kp_P&
>      &ROT.BIN',
> C    &ROT.ASC',
752,754c870,872
<       WRITE(*,*)
<       WRITE(*,*)' Read CRMFLX magnetosheath data file.'
<       WRITE(*,*)
---
> D     WRITE(*,*)
> D     WRITE(*,*)' Read CRMFLX magnetosheath data file.'
> D     WRITE(*,*)
802c920
< C       LUNIT   - unit number used in opening CRM`s database.
---
> C       LUNIT   - unit number used in opening CRM's database.
819,821c937,940
<         OPEN(LUNIT,FILE='/data/mta4/proj/rac/ops/CRM/v1.21/crmflx_v1.2_2&
<      &5jan2001/SolWind_Kp_PROT.BIN',
< c    &5jan2001/SolWind_Kp_PROT.ASC',
---
>         OPEN(LUNIT,FILE=
>      $  '/data/mta4/proj/rac/ops/CRM2/v26apr2004/crmflx_v23/SolWind_Kp_P&
>      &ROT.BIN',
> C    &ROT.ASC',
843,845c962,964
< C     WRITE(*,*)
< C     WRITE(*,*)' Read CRMFLX solar wind data file.'
< C     WRITE(*,*)
---
> D     WRITE(*,*)
> D     WRITE(*,*)' Read CRMFLX solar wind data file.'
> D     WRITE(*,*)
855,856c974
< DD      write(*,*) "I AM HERE ICNT ", icnt, lunit,maxkp
<         READ(LUNIT, ERR=1001,END=1002) I,J,K,XD,YD,ZD,
---
>         READ(LUNIT,ERR=1001,END=1002) I,J,K,XD,YD,ZD,
890c1008
< c subroutine to solve the equations 21-24 in Bennet`s paper for the
---
> c subroutine to solve the equations 21-24 in Bennet's paper for the
897c1015
< C     "A Model of the Earth`s Distant Bow Shock."  This paper was
---
> C     "A Model of the Earth's Distant Bow Shock."  This paper was
989c1107
< C     This routine finds the flux corresponding to the satellite`s
---
> C     This routine finds the flux corresponding to the satellite's
997,999c1115,1117
< C       XGSM    - satellite`s X-coordinate (Re).
< C       YGSM    - satellite`s Y-coordinate (Re).
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
1002c1120
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1004c1122
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1006c1124
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1037a1156
> D     WRITE(*,*)' RNGCHK = ',RNGCHK
1098d1216
< 
1116c1234
< C           tolerance to the nearest neighbor.  This cell`s flux
---
> C           tolerance to the nearest neighbor.  This cell's flux
1154a1273,1636
>       SUBROUTINE FLXDAT1_MAP(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $  IMAPINDX,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used if no data smoothing is selected or if
> C     spatial averaging within the volume defined by RNGCHK is selected.
> C
> C     This routine is used if the database has been populated by use
> C     of streamline mapping.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C
> C     OUTPUTS:
> C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM  - average number of flux values per cell used to get FLUX.
> C       RNGCELL - distance to center of flux database cell used  (Re).
> C       NUMCELL - number of flux database cells used that have the
> C                 same value of RNGCELL.
> C
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT1_MAP!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' NSPHVOL,RNGCHK = ',NSPHVOL,RNGCHK
> D     DO I = 1,NSPHVOL
> D       WRITE(*,*)' I = ',I
> D       WRITE(*,*)' IOFFSET(I) = ',IOFFSET(I)
> D       WRITE(*,*)' JOFFSET(I) = ',JOFFSET(I)
> D       WRITE(*,*)' KOFFSET(I) = ',KOFFSET(I)
> D     END DO
> D     PAUSE 'PAUSED!!'
> C
> C     Find the nearest non-zero data cell.  Use its flux value.
> C
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             XVE = XFLUX(IKP,INDEXNOW)
>             YVE = YFLUX(IKP,INDEXNOW)
>             ZVE = ZFLUX(IKP,INDEXNOW)
>             RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>             RNGDIFF = RNG - RNGCELL
>             RNGABS = ABS(RNGDIFF)
> D           WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D           WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D           WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>             IF(NUMCELL.EQ.0) THEN
> CCC         IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C             There is a new nearest neighbor data cell.
>               NUMCELL = 1
> D             WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>               RNGCELL = RNG
>               FLXSTO(1) = FVE
>               NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>             ELSE 
>               IF(RNGABS.LE.RNGCHK) THEN
> C               There is a new data cell within the range
> C               tolerance to the nearest neighbor.  This cell's flux
> C               should be included in the average for this location.
>                 NUMCELL = NUMCELL + 1
> D               WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                 FLXSTO(NUMCELL) = FVE
>                 NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                 IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>               ELSE
>                 GO TO 1000
>               END IF
>             END IF
> D           WRITE(*,*)' I,NUMCELL,RNGCELL,MAXCELL = ',
> D    $                  I,NUMCELL,RNGCELL,MAXCELL
> D           WRITE(*,*)' FLXSTO(NUMCELL),NUMSTO(NUMCELL) = ',
> D    $                  FLXSTO(NUMCELL),NUMSTO(NUMCELL)
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
> C     Use the average of the flux from all bins at the same distance.
> C
>       FLUX = 0.
>       AVGNUM = 0.
>       IF(NUMCELL.EQ.1) THEN
>         FLUX = FLXSTO(1)
>         AVGNUM = FLOAT(NUMSTO(1))
>       ELSE IF(NUMCELL.GT.1) THEN
>         NUMAVG = 0
>         DO I = 1,NUMCELL
>           FLUX = FLUX + FLXSTO(I)
>           NUMAVG = NUMAVG + NUMSTO(I)
>         END DO
>         FLUX = FLUX/FLOAT(NUMCELL)
>         AVGNUM = FLOAT(NUMAVG)/FLOAT(NUMCELL)
>       END IF
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT1_MAP!!'
> D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
> D     WRITE(*,*)
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT1_MAP_Z(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $  IMAPINDX,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used if no data smoothing is selected or if
> C     spatial averaging within the volume defined by RNGCHK is selected.
> C
> C     This routine is used if the database has been populated by use
> C     of streamline mapping.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C
> C     OUTPUTS:
> C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM  - average number of flux values per cell used to get FLUX.
> C       RNGCELL - distance to center of flux database cell used  (Re).
> C       NUMCELL - number of flux database cells used that have the
> C                 same value of RNGCELL.
> C
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT1_MAP_Z!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' NSPHVOL,RNGCHK = ',NSPHVOL,RNGCHK
> D     DO I = 1,NSPHVOL
> D       WRITE(*,*)' I = ',I
> D       WRITE(*,*)' IOFFSET(I) = ',IOFFSET(I)
> D       WRITE(*,*)' JOFFSET(I) = ',JOFFSET(I)
> D       WRITE(*,*)' KOFFSET(I) = ',KOFFSET(I)
> D     END DO
> D     PAUSE 'PAUSED!!'
> C
> C     Find the nearest non-zero data cell.  Use its flux value.
> C
> C
> C     Get the limits on z-values used to search for near-neighbors.
> C
>       CALL ZBINNER(XGSM,ZGSM,ZCKLO,ZCKHI)
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
> D       IF(I.EQ.14060) THEN
> D         WRITE(*,*)' ******'
> D         WRITE(*,*)' I,II,JJ,KK,IKP = ',I,II,JJ,KK,IKP
> D         WRITE(*,*)' NSPHVOL = ',NSPHVOL
> D         WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D         WRITE(*,*)' XMIN,YMIN,ZMIN = ',XMIN,YMIN,ZMIN
> D         WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
> D         WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> D         WRITE(*,*)' I,IOFFSET(I),JOFFSET(I),KOFFSET(I) = ',
> D    $                I,IOFFSET(I),JOFFSET(I),KOFFSET(I)
> D         WRITE(*,*)' ******'
> D       END IF
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             ZVE = ZFLUX(IKP,INDEXNOW)
> D           WRITE(*,*)' ZGSM,ZVE,ZCKLO,ZCKHI = ',ZGSM,ZVE,ZCKLO,ZCKHI
> D           PAUSE 'PAUSED!'
>             IF((ZVE.GE.ZCKLO).AND.(ZVE.LE.ZCKHI)) THEN
>               XVE = XFLUX(IKP,INDEXNOW)
>               YVE = YFLUX(IKP,INDEXNOW)
>               RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>               RNGDIFF = RNG - RNGCELL
>               RNGABS = ABS(RNGDIFF)
> D             WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D             WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D             WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>               IF(NUMCELL.EQ.0) THEN
> CCC           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C               There is a new nearest neighbor data cell.
>                 NUMCELL = 1
> D               WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>                 RNGCELL = RNG
>                 FLXSTO(1) = FVE
>                 NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>               ELSE 
>                 IF(RNGABS.LE.RNGCHK) THEN
> C                 There is a new data cell within the range
> C                 tolerance to the nearest neighbor.  This cell's flux
> C                 should be included in the average for this location.
>                   NUMCELL = NUMCELL + 1
> D                 WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                   FLXSTO(NUMCELL) = FVE
>                   NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                   IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>                 ELSE
>                   GO TO 1000
>                 END IF
>               END IF
>             END IF
> D           WRITE(*,*)' I,NUMCELL,RNGCELL,MAXCELL = ',
> D    $                  I,NUMCELL,RNGCELL,MAXCELL
> D           WRITE(*,*)' FLXSTO(NUMCELL),NUMSTO(NUMCELL) = ',
> D    $                  FLXSTO(NUMCELL),NUMSTO(NUMCELL)
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
> C     Use the average of the flux from all bins at the same distance.
> C
>       FLUX = 0.
>       AVGNUM = 0.
>       IF(NUMCELL.EQ.1) THEN
>         FLUX = FLXSTO(1)
>         AVGNUM = FLOAT(NUMSTO(1))
>       ELSE IF(NUMCELL.GT.1) THEN
>         NUMAVG = 0
>         DO I = 1,NUMCELL
>           FLUX = FLUX + FLXSTO(I)
>           NUMAVG = NUMAVG + NUMSTO(I)
>         END DO
>         FLUX = FLUX/FLOAT(NUMCELL)
>         AVGNUM = FLOAT(NUMAVG)/FLOAT(NUMCELL)
>       END IF
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT1_MAP_Z!!'
> D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
> D     WRITE(*,*)
> C
>       RETURN
>       END
> C
> C
1159c1641
< C     This routine finds the flux corresponding to the satellite`s
---
> C     This routine finds the flux corresponding to the satellite's
1166,1168c1648,1650
< C       XGSM    - satellite`s X-coordinate (Re).
< C       YGSM    - satellite`s Y-coordinate (Re).
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
1171c1653
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1173c1655
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1175c1657
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1310c1792
< C (6) Repeat this process until you multiply the farthest data cell`s by
---
> C (6) Repeat this process until you multiply the farthest data cell's by
1534,1535c2016,2018
<       SUBROUTINE FLXDAT3(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $  FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,FLUX,AVGNUM,
---
>       SUBROUTINE FLXDAT2_MAP(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $  LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX,DISNUM,
1538c2021
< C     This routine finds the flux corresponding to the satellite`s
---
> C     This routine finds the flux corresponding to the satellite's
1541,1543c2024
< C     This routine is used to calculate the spatial average of flux in a
< C     volume given by RNGCHK, with the specified number of high and low
< C     flux values inside the volume dropped first.
---
> C     This routine uses spike rejection to filter (smooth) the data.
1547,1549c2028,2030
< C       XGSM    - satellite`s X-coordinate (Re).
< C       YGSM    - satellite`s Y-coordinate (Re).
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
1552c2033
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1554c2035
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1556c2037
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1560d2040
< C                 each cell.
1561a2042,2049
> C       SMOOTH1 - flag for control of database smoothing filter:
> C              SMOOTH1 = 1 if spike rejection and near neighbor flux.
> C              SMOOTH1 = 2 if spike rejection with range weighted
> C                           scaling of flux.
> C              SMOOTH1 = 3 if spike rejection with average flux.
> C       NFLXGET - number of flux values to get for smoothing filter
> C                  (used if SMOOTH1 = 1,2, or 3)
> C
1563c2051
< C                  filter.
---
> C                  filter (used if SMOOTH1 = 1,2, or 3).
1566c2054
< C                  filter.
---
> C                  filter (used if SMOOTH1 = 1,2, or 3).
1568a2057
> C                  (used if SMOOTH1 = 3).
1570a2060,2065
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
1573,1577c2068,2073
< C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
< C       AVGNUM  - average number of flux values per cell used to get FLUX.
< C       RNGCELL - distance to center of flux database cell used  (Re).
< C       NUMCELL - number of flux database cells used that have the
< C                 same value of RNGCELL.
---
> C       FLUX    - computed distance weighted flux value (ions/[cm^2-sec-sr-MeV]).
> C       DISNUM  - distance weighted number of flux values per cell used
> C                 to get FLUX.
> C       RNGCELL - distance to center of nearest flux database cell
> C                 used  (Re).
> C       NUMCELL - number of flux database cells used.
1581c2077,2083
<       INCLUDE 'MAXCELL.PAR'
---
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
1587,1588c2089,2090
<       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
<       INTEGER NUMSTO(MAXCELL)
---
>       REAL FLXSTO(NSAVE),RNGSTO(NSAVE)
>       INTEGER NUMSTO(NSAVE)
1590,1591c2092,2095
<       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
<       INTEGER NUMUSE(MAXCELL)
---
>       REAL FLXUSE(NSAVE),RNGUSE(NSAVE)
>       INTEGER NUMUSE(NSAVE)
> C
>       INTEGER SMOOTH1
1594c2098
< D     WRITE(*,*)' ENTERED FLXDAT3!!'
---
> D     WRITE(*,*)' ENTERED FLXDAT2_MAP!!'
1600,1601c2104
< D     WRITE(*,*)' LOGFLG,RNGCHK,NDROPHI,NDROPLO = ',
< D    $            LOGFLG,RNGCHK,NDROPHI,NDROPLO
---
> D     WRITE(*,*)' RNGCHK,SMOOTH1 = ',RNGCHK,SMOOTH1
1604d2106
< C     Find the nearest non-zero data cell.  Use its flux value.
1606,1653c2108
<       IF(XGSM.GE.0.) THEN
< C       Do not use Z-layers on the dayside of the magnetosphere.
<         ZCKLO = -7.
<         ZCKHI = +100.
<       ELSE
< C       Use the nearest neighbor flux only inside a range of Z-values.
<         IF(ZGSM.LE.-6.) THEN
< C         Use the nearest neighbor in the -7 < Z < -6. range.
<           ZCKLO = -7.
<           ZCKHI = -6.
<         ELSE IF((ZGSM.GT.-6.).AND.(ZGSM.LE.-5.)) THEN
< C         Use the nearest neighbor in the -6 < Z < -5. range.
<           ZCKLO = -6.
<           ZCKHI = -5.
<         ELSE IF((ZGSM.GT.-5.).AND.(ZGSM.LE.+4.)) THEN
< C         Use the nearest neighbor in the -5 < Z < +4. range.
<           ZCKLO = -5.
<           ZCKHI = +4.
<         ELSE IF((ZGSM.GT.+4.).AND.(ZGSM.LE.+5.)) THEN
< C         Use the nearest neighbor in the +4 < Z < +5. range.
<           ZCKLO = +4.
<           ZCKHI = +5.
<         ELSE IF((ZGSM.GT.+5.).AND.(ZGSM.LE.+6.)) THEN
< C         Use the nearest neighbor in the +5 < Z < +6. range.
<           ZCKLO = +5.
<           ZCKHI = +6.
<         ELSE IF((ZGSM.GT.+6.).AND.(ZGSM.LE.+7.)) THEN
< C         Use the nearest neighbor in the +6 < Z < +7. range.
<           ZCKLO = +6.
<           ZCKHI = +7.
<         ELSE IF((ZGSM.GT.+7.).AND.(ZGSM.LE.+8.)) THEN
< C         Use the nearest neighbor in the +7 < Z < +8. range.
<           ZCKLO = +7.
<           ZCKHI = +8.
<         ELSE IF((ZGSM.GT.+8.).AND.(ZGSM.LE.+9.)) THEN
< C         Use the nearest neighbor in the +8 < Z < +9. range.
<           ZCKLO = +8.
<           ZCKHI = +9.
<         ELSE IF((ZGSM.GT.+9.).AND.(ZGSM.LE.+10.)) THEN
< C         Use the nearest neighbor in the +9 < Z < +10. range.
<           ZCKLO = +9.
<           ZCKHI = +10.
<         ELSE IF(ZGSM.GT.+10.) THEN
< C         Use the nearest neighbor in the +10 < Z < +11. range.
<           ZCKLO = +10.
<           ZCKHI = +11.
<         END IF
<       END IF
---
> C     *********** (IUSE out of NFLXGET) Algorithm Description ************
1655c2110,2113
< D     WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
---
> C (1) Find the NFLXGET nearest neighbor data cells (with respect to the
> C     observation point) which lie within the z-slice of the observation
> C     point (not the range from the nearest neighbor data cell as used
> C     previously).
1657,1686c2115,2198
<       RNGCELL = 1.E+25
<       NUMCELL = 0
<       DO I = 1,NUMDAT(IKP)
<         IF((FLUXBIN(IKP,I) .GT.1.).AND.(ZFLUX(IKP,I).GT.ZCKLO)
<      $     .AND.(ZFLUX(IKP,I).LE.ZCKHI)) THEN
<           RNG = SQRT((XFLUX(IKP,I)-XGSM)**2 + (YFLUX(IKP,I)-YGSM)**2
<      $      + (ZFLUX(IKP,I)-ZGSM)**2)
< D         WRITE(*,*)' I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),',
< D    $              'ZFLUX(IKP,I) = ',
< D    $                I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),
< D    $               ZFLUX(IKP,I)
< D         WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
<           RNGDIFF = RNG - RNGCELL
<           RNGABS = ABS(RNGDIFF)
<           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
< C           There is a new nearest neighbor data cell.
<             NUMCELL = 1
<             RNGCELL = RNG
<             RNGSTO(1) = RNG
<             FLXSTO(1) = FLUXBIN(IKP,I)
<             NUMSTO(1) = NUMBIN(IKP,I)
<           ELSE IF(RNGABS.LE.RNGCHK) THEN
< C           There is a new data cell within the range
< C           tolerance to the nearest neighbor.  This cell`s flux
< C           should be included in the average for this location.
<             NUMCELL = NUMCELL + 1
<             RNGSTO(NUMCELL) = RNG
<             FLXSTO(NUMCELL) = FLUXBIN(IKP,I)
<             NUMSTO(NUMCELL) = NUMBIN(IKP,I)
<             IF(NUMCELL.EQ.MAXCELL) GO TO 1000
---
> C (2) Sort the NFLXGET data cells by their range from the observation
> C     point.
> C
> C (3) Throw away the highest flux value and lowest flux value data
> C     cells.  So, IUSE = NFLXGET - 2.
> C
> C     *** NOTE *** For the remaining IUSE data cells, this routine
> C     calculates the distance weighted sum of the flux values.  The
> C     objective of this approach is to smooth the database by taking
> C     out the +/- "spikes" and performing a spatial blending of the
> C     remaining data. This approach is very similar to that used for the
> C     Kp scaling factors.
> C
> C (4) Multiply the closest data cell by the distance to the farthest
> C     data cell.
> C
> C (5) Multiply the 2nd closest data cell by the distance to the 2nd
> C     farthest data cell.
> C
> C (6) Repeat this process until you multiply the farthest data cell's by
> C     the distance to the closest data cell.
> C
> C (7) Get the final ion flux by summing the distance scaled quantities
> C     and dividing the sum by the total distance to all of the data
> C     cells.
> C
> C (8) Get the distance weighted sum of the number of flux values per
> C     cell used to get FLUX.  Repeat steps 4 -> 7 above, but for the
> C     number of flux measurements per data cell (not for the average
> C     flux value in that cell).
> C
> C     ***************** End of Algorithm Description *******************
> C
> C
> D     WRITE(*,*)' NFLXGET,NDROPHI,NDROPLO,LOGFLG = ',
> D    $            NFLXGET,NDROPHI,NDROPLO,LOGFLG
> D     PAUSE
> C
> C
> C     Gather the NFLXGET flux values.
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       NGOT = 1
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             XVE = XFLUX(IKP,INDEXNOW)
>             YVE = YFLUX(IKP,INDEXNOW)
>             ZVE = ZFLUX(IKP,INDEXNOW)
>             RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
> D           WRITE(*,*)' I,RNG = ',I,RNG
> C
>             IF(NGOT.LT.NFLXGET) THEN
> C             Increment the counter and save the data cell information.
>               RNGSTO(NGOT) = RNG
>               FLXSTO(NGOT) = FVE
>               NUMSTO(NGOT)  = NUMBIN(IKP,INDEXNOW)
>               NGOT = NGOT + 1
>             ELSE IF(NGOT.EQ.NFLXGET) THEN
> C             Save the data cell information and sort the NFLXGET data cells
> C             (in ascending order) on the basis of their ranges from the
> C             observation point.
>               RNGSTO(NFLXGET) = RNG
>               FLXSTO(NFLXGET) = FVE
>               NUMSTO(NFLXGET)  = NUMBIN(IKP,INDEXNOW)
>               CALL SORTRG5(NFLXGET,RNGSTO,FLXSTO,NUMSTO)
>               GO TO 1000
>             END IF
1688a2201
>         END IF
1693c2206,2213
<       NDO = NUMCELL
---
> D     WRITE(*,*)' BEFORE HIGH INDEX!'
> D     DO I = 1,NFLXGET
> D       WRITE(*,*)' RNGSTO(I),FLXSTO(I),NUMSTO(I) = ',
> D    $              RNGSTO(I),FLXSTO(I),NUMSTO(I)
> D     END DO
> D     PAUSE
> C
>       NDO = NFLXGET
1707c2227
< C       Save the IUSE data cells` information to the work arrays.
---
> C       Save the IUSE data cells' information to the work arrays.
1767c2287
<         AVGNUM = FLOAT(NUMUSE(1))
---
>         DISNUM = FLOAT(NUMUSE(1))
1774,1789c2294,2345
< C     Get average flux.
<       FLUX = 0.0
<       AVGNUM = 0.0
<       RNGCELL = 0.0
<       DO I = 1,IUSE
<         IF(LOGFLG.EQ.1) THEN
<           FLUX   = FLUX   + LOG10(FLXUSE(I))
<         ELSE
<           FLUX   = FLUX   + FLXUSE(I)
<         END IF
<         AVGNUM = AVGNUM + FLOAT(NUMUSE(I))
<         RNGCELL = RNGCELL + RNGUSE(I)
<       END DO
<       FLUX = FLUX/FLOAT(IUSE)
<       AVGNUM = AVGNUM/FLOAT(IUSE)
<       RNGCELL = RNGCELL/FLOAT(IUSE)
---
> C     The spike rejection process is complete.  Calculate the final
> C     flux value.
> C
>       IF(SMOOTH1.EQ.1) THEN
> C       Find the near-neighbor flux.
>         DISNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>         RETURN
>       ELSE IF(SMOOTH1.EQ.2) THEN
> C       Calculate the distance weighted sum of the flux and NUMBIN
> C       values.
> C
>         FLUX = 0.0
>         DISNUM = 0.0
>         DTOT = 0.0
>         DO I = 1,IUSE
>           DTOT = DTOT + RNGUSE(I)
>           J = IUSE - I + 1
>           WEIGHT = RNGUSE(J)
>           IF(LOGFLG.EQ.1) THEN
>             FLUX   = FLUX   + LOG10(FLXUSE(I))*WEIGHT
>           ELSE
>             FLUX   = FLUX   + FLXUSE(I)*WEIGHT
>           END IF
>           DISNUM = DISNUM + FLOAT(NUMUSE(I))*WEIGHT
>         END DO
> C
>         FLUX = FLUX/DTOT
>         DISNUM = DISNUM/DTOT
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>       ELSE
> C       Get average flux.
>         FLUX = 0.0
>         DISNUM = 0.0
>         DO I = 1,IUSE
>           IF(LOGFLG.EQ.1) THEN
>             FLUX   = FLUX   + LOG10(FLXUSE(I))
>           ELSE
>             FLUX   = FLUX   + FLXUSE(I)
>           END IF
>           DISNUM = DISNUM + FLOAT(NUMUSE(I))
>         END DO
>         FLUX = FLUX/FLOAT(IUSE)
>         DISNUM = DISNUM/FLOAT(IUSE)
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>       END IF
1792a2349
>       RNGCELL = RNGUSE(1)
1796,1797c2353,2355
< D     WRITE(*,*)' END FLXDAT3!!'
< D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
---
> D     WRITE(*,*)' END FLXDAT2_MAP!!'
> D     WRITE(*,*)' DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $            DISNUM,RNGCELL,NUMCELL,FLUX
1799d2356
< D     PAUSE 'PAUSED!'
1801c2358
<       RETURN
---
>       RETURN 
1805,1806c2362,2364
<       SUBROUTINE FLXDAT4(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $  FLUXBIN,NUMBIN,RNGCHK,LOGFLG,FPCHI,FPCLO,FLUX,AVGNUM,
---
>       SUBROUTINE FLXDAT2_MAP_Z(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $  LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX,DISNUM,
1809c2367
< C     This routine finds the flux corresponding to the satellite`s
---
> C     This routine finds the flux corresponding to the satellite's
1812,1814c2370
< C     This routine is used to calculate the spatial average of flux in a
< C     volume given by RNGCHK, with percentile threshold limits on flux
< C     values.
---
> C     This routine uses spike rejection to filter (smooth) the data.
1818,1820c2374,2376
< C       XGSM    - satellite`s X-coordinate (Re).
< C       YGSM    - satellite`s Y-coordinate (Re).
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
1823c2379
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1825c2381
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1827c2383
< C                 cell`s center  (Re).
---
> C                 cell's center  (Re).
1831d2386
< C                 each cell.
1832a2388,2401
> C       SMOOTH1 - flag for control of database smoothing filter:
> C              SMOOTH1 = 1 if spike rejection and near neighbor flux.
> C              SMOOTH1 = 2 if spike rejection with range weighted
> C                           scaling of flux.
> C              SMOOTH1 = 3 if spike rejection with average flux.
> C       NFLXGET - number of flux values to get for smoothing filter
> C                  (used if SMOOTH1 = 1,2, or 3)
> C
> C       NDROPHI - number of high flux values to drop for smoothing
> C                  filter (used if SMOOTH1 = 1,2, or 3).
> C
> C       NDROPLO - number of low flux values to drop for smoothing
> C                  filter (used if SMOOTH1 = 1,2, or 3).
> C
1833a2403
> C                  (used if SMOOTH1 = 3).
1836,1837c2406,2411
< C       FPCHI   - upper percentile limit for spatial averaging of flux
< C       FPCLO   - lower percentile limit for spatial averaging of flux
---
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
1840,1844c2414,2419
< C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
< C       AVGNUM  - average number of flux values per cell used to get FLUX.
< C       RNGCELL - distance to center of flux database cell used  (Re).
< C       NUMCELL - number of flux database cells used that have the
< C                 same value of RNGCELL.
---
> C       FLUX    - computed distance weighted flux value (ions/[cm^2-sec-sr-MeV]).
> C       DISNUM  - distance weighted number of flux values per cell used
> C                 to get FLUX.
> C       RNGCELL - distance to center of nearest flux database cell
> C                 used  (Re).
> C       NUMCELL - number of flux database cells used.
1848c2423,2429
<       INCLUDE 'MAXCELL.PAR'
---
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
1854,1855c2435,2436
<       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
<       INTEGER NUMSTO(MAXCELL)
---
>       REAL FLXSTO(NSAVE),RNGSTO(NSAVE)
>       INTEGER NUMSTO(NSAVE)
1857,1858c2438,2439
<       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
<       INTEGER NUMUSE(MAXCELL)
---
>       REAL FLXUSE(NSAVE),RNGUSE(NSAVE)
>       INTEGER NUMUSE(NSAVE)
1860c2441
<       INTEGER FPCHI,FPCLO
---
>       INTEGER SMOOTH1
1863c2444
< D     WRITE(*,*)' ENTERED FLXDAT4!!'
---
> D     WRITE(*,*)' ENTERED FLXDAT2_MAP_Z!!'
1869,1870c2450,2496
< D     WRITE(*,*)' LOGFLG,RNGCHK,FPCHI,FPCLO = ',
< D    $            LOGFLG,RNGCHK,FPCHI,FPCLO
---
> D     WRITE(*,*)' RNGCHK,SMOOTH1 = ',RNGCHK,SMOOTH1
> D     PAUSE 'PAUSED!'
> C
> C
> C     *********** (IUSE out of NFLXGET) Algorithm Description ************
> C
> C (1) Find the NFLXGET nearest neighbor data cells (with respect to the
> C     observation point) which lie within the z-slice of the observation
> C     point (not the range from the nearest neighbor data cell as used
> C     previously).
> C
> C (2) Sort the NFLXGET data cells by their range from the observation
> C     point.
> C
> C (3) Throw away the highest flux value and lowest flux value data
> C     cells.  So, IUSE = NFLXGET - 2.
> C
> C     *** NOTE *** For the remaining IUSE data cells, this routine
> C     calculates the distance weighted sum of the flux values.  The
> C     objective of this approach is to smooth the database by taking
> C     out the +/- "spikes" and performing a spatial blending of the
> C     remaining data. This approach is very similar to that used for the
> C     Kp scaling factors.
> C
> C (4) Multiply the closest data cell by the distance to the farthest
> C     data cell.
> C
> C (5) Multiply the 2nd closest data cell by the distance to the 2nd
> C     farthest data cell.
> C
> C (6) Repeat this process until you multiply the farthest data cell's by
> C     the distance to the closest data cell.
> C
> C (7) Get the final ion flux by summing the distance scaled quantities
> C     and dividing the sum by the total distance to all of the data
> C     cells.
> C
> C (8) Get the distance weighted sum of the number of flux values per
> C     cell used to get FLUX.  Repeat steps 4 -> 7 above, but for the
> C     number of flux measurements per data cell (not for the average
> C     flux value in that cell).
> C
> C     ***************** End of Algorithm Description *******************
> C
> C
> D     WRITE(*,*)' NFLXGET,NDROPHI,NDROPLO,LOGFLG = ',
> D    $            NFLXGET,NDROPHI,NDROPLO,LOGFLG
1873d2498
< C     Find the nearest non-zero data cell.  Use its flux value.
1875,1922c2500
<       IF(XGSM.GE.0.) THEN
< C       Do not use Z-layers on the dayside of the magnetosphere.
<         ZCKLO = -7.
<         ZCKHI = +100.
<       ELSE
< C       Use the nearest neighbor flux only inside a range of Z-values.
<         IF(ZGSM.LE.-6.) THEN
< C         Use the nearest neighbor in the -7 < Z < -6. range.
<           ZCKLO = -7.
<           ZCKHI = -6.
<         ELSE IF((ZGSM.GT.-6.).AND.(ZGSM.LE.-5.)) THEN
< C         Use the nearest neighbor in the -6 < Z < -5. range.
<           ZCKLO = -6.
<           ZCKHI = -5.
<         ELSE IF((ZGSM.GT.-5.).AND.(ZGSM.LE.+4.)) THEN
< C         Use the nearest neighbor in the -5 < Z < +4. range.
<           ZCKLO = -5.
<           ZCKHI = +4.
<         ELSE IF((ZGSM.GT.+4.).AND.(ZGSM.LE.+5.)) THEN
< C         Use the nearest neighbor in the +4 < Z < +5. range.
<           ZCKLO = +4.
<           ZCKHI = +5.
<         ELSE IF((ZGSM.GT.+5.).AND.(ZGSM.LE.+6.)) THEN
< C         Use the nearest neighbor in the +5 < Z < +6. range.
<           ZCKLO = +5.
<           ZCKHI = +6.
<         ELSE IF((ZGSM.GT.+6.).AND.(ZGSM.LE.+7.)) THEN
< C         Use the nearest neighbor in the +6 < Z < +7. range.
<           ZCKLO = +6.
<           ZCKHI = +7.
<         ELSE IF((ZGSM.GT.+7.).AND.(ZGSM.LE.+8.)) THEN
< C         Use the nearest neighbor in the +7 < Z < +8. range.
<           ZCKLO = +7.
<           ZCKHI = +8.
<         ELSE IF((ZGSM.GT.+8.).AND.(ZGSM.LE.+9.)) THEN
< C         Use the nearest neighbor in the +8 < Z < +9. range.
<           ZCKLO = +8.
<           ZCKHI = +9.
<         ELSE IF((ZGSM.GT.+9.).AND.(ZGSM.LE.+10.)) THEN
< C         Use the nearest neighbor in the +9 < Z < +10. range.
<           ZCKLO = +9.
<           ZCKHI = +10.
<         ELSE IF(ZGSM.GT.+10.) THEN
< C         Use the nearest neighbor in the +10 < Z < +11. range.
<           ZCKLO = +10.
<           ZCKHI = +11.
<         END IF
<       END IF
---
> C     Gather the NFLXGET flux values.
1924c2502
< D     WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
---
> C     Get the limits on z-values used to search for near-neighbors.
1926,1955c2504,2552
<       RNGCELL = 1.E+25
<       NUMCELL = 0
<       DO I = 1,NUMDAT(IKP)
<         IF((FLUXBIN(IKP,I) .GT.1.).AND.(ZFLUX(IKP,I).GT.ZCKLO)
<      $     .AND.(ZFLUX(IKP,I).LE.ZCKHI)) THEN
<           RNG = SQRT((XFLUX(IKP,I)-XGSM)**2 + (YFLUX(IKP,I)-YGSM)**2
<      $      + (ZFLUX(IKP,I)-ZGSM)**2)
< D         WRITE(*,*)' I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),',
< D    $              'ZFLUX(IKP,I) = ',
< D    $                I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),
< D    $               ZFLUX(IKP,I)
< D         WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
<           RNGDIFF = RNG - RNGCELL
<           RNGABS = ABS(RNGDIFF)
<           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
< C           There is a new nearest neighbor data cell.
<             NUMCELL = 1
<             RNGCELL = RNG
<             RNGSTO(1) = RNG
<             FLXSTO(1) = FLUXBIN(IKP,I)
<             NUMSTO(1) = NUMBIN(IKP,I)
<           ELSE IF(RNGABS.LE.RNGCHK) THEN
< C           There is a new data cell within the range
< C           tolerance to the nearest neighbor.  This cell`s flux
< C           should be included in the average for this location.
<             NUMCELL = NUMCELL + 1
<             RNGSTO(NUMCELL) = RNG
<             FLXSTO(NUMCELL) = FLUXBIN(IKP,I)
<             NUMSTO(NUMCELL) = NUMBIN(IKP,I)
<             IF(NUMCELL.EQ.MAXCELL) GO TO 1000
---
>       CALL ZBINNER(XGSM,ZGSM,ZCKLO,ZCKHI)
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       NGOT = 1
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             ZVE = ZFLUX(IKP,INDEXNOW)
> D           WRITE(*,*)' ZGSM,ZVE,ZCKLO,ZCKHI = ',ZGSM,ZVE,ZCKLO,ZCKHI
> D           PAUSE 'PAUSED!'
>             IF((ZVE.GE.ZCKLO).AND.(ZVE.LE.ZCKHI)) THEN
>               XVE = XFLUX(IKP,INDEXNOW)
>               YVE = YFLUX(IKP,INDEXNOW)
>               RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
> D             WRITE(*,*)' I,RNG = ',I,RNG
> C
>               IF(NGOT.LT.NFLXGET) THEN
> C               Increment the counter and save the data cell information.
>                 RNGSTO(NGOT) = RNG
>                 FLXSTO(NGOT) = FVE
>                 NUMSTO(NGOT)  = NUMBIN(IKP,INDEXNOW)
>                 NGOT = NGOT + 1
>               ELSE IF(NGOT.EQ.NFLXGET) THEN
> C               Save the data cell information and sort the NFLXGET data cells
> C               (in ascending order) on the basis of their ranges from the
> C               observation point.
>                 RNGSTO(NFLXGET) = RNG
>                 FLXSTO(NFLXGET) = FVE
>                 NUMSTO(NFLXGET)  = NUMBIN(IKP,INDEXNOW)
>                 CALL SORTRG5(NFLXGET,RNGSTO,FLXSTO,NUMSTO)
>                 GO TO 1000
>               END IF
>             END IF
1957a2555
>         END IF
1962,1964c2560,2565
< C     Calculate the flux statistics for the values inside this volume.
<       CALL STATFLX(NUMCELL,RNGSTO,NUMSTO,FLXSTO,FPCHI,FPCLO,FMEAN,FLXHI,
<      $  FLXLO,FSIG,FMAX,FMIN)
---
> D     WRITE(*,*)' BEFORE HIGH INDEX!'
> D     DO I = 1,NFLXGET
> D       WRITE(*,*)' RNGSTO(I),FLXSTO(I),NUMSTO(I) = ',
> D    $              RNGSTO(I),FLXSTO(I),NUMSTO(I)
> D     END DO
> D     PAUSE
1966,1969c2567,2601
< D     WRITE(*,*)' FPCHI,FPCLO,FLXHI,FLXLO = ',FPCHI,FPCLO,FLXHI,FLXLO
< D     DO I = 1,NUMCELL
< D       WRITE(*,*)' I,RNGSTO(I),NUMSTO(I),FLXSTO(I) = ',
< D    $              I,RNGSTO(I),NUMSTO(I),FLXSTO(I)
---
>       NDO = NFLXGET
>       DO J =1,NDROPHI
> C
> C       Find the index of the high flux value data cell.
> C
>         FLXMAX = 0.0
>         DO I = 1,NDO
>           IF(FLXSTO(I).GE.FLXMAX) THEN
>             FLXMAX = FLXSTO(I)
>             INDMAX = I
>           END IF
>         END DO
> D       WRITE(*,*)' J,NDO,INDMAX,FLXMAX = ',J,NDO,INDMAX,FLXMAX
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMAX) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
> D           WRITE(*,*)' J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),',
> D    $                 'NUMUSE(IUSE) = ',
> D    $                  J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER HIGH INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
1970a2603
> D     PAUSE
1972,1973c2605,2606
< C     Throw out flux values in the table that are above FLXHI or
< C     below FLXLO.
---
>       NDO = IUSE
>       DO J =1,NDROPLO
1975,1985c2608,2629
<       IUSE = 0
<       DO I = 1,NUMCELL
<         IF((FLXSTO(I).LT.FLXHI).AND.(FLXSTO(I).GT.FLXLO)) THEN
< C         Use this flux value to perform spatial averaging.
<           IUSE = IUSE + 1
<           RNGUSE(IUSE) = RNGSTO(I)
<           FLXUSE(IUSE) = FLXSTO(I)
<           NUMUSE(IUSE) = NUMSTO(I)
< D         WRITE(*,*)' IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE) = ',
< D    $                IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
<         END IF
---
> C       Find the index of the low flux value data cell.
> C
>         FLXMIN = 1.E+25
>         DO I = 1,NDO
>           IF(FLXSTO(I).LE.FLXMIN) THEN
>             FLXMIN = FLXSTO(I)
>             INDMIN = I
>           END IF
>         END DO
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMIN) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
>           END IF
>         END DO
1987a2632,2637
> D     WRITE(*,*)' AFTER LOW INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
1991c2641
<         AVGNUM = FLOAT(NUMUSE(1))
---
>         DISNUM = FLOAT(NUMUSE(1))
1998,2006c2648,4821
< C     Get average flux.
<       FLUX = 0.0
<       AVGNUM = 0.0
<       RNGCELL = 0.0
<       DO I = 1,IUSE
<         IF(LOGFLG.EQ.1) THEN
<           FLUX   = FLUX   + LOG10(FLXUSE(I))
<         ELSE
<           FLUX   = FLUX   + FLXUSE(I)
---
> C     The spike rejection process is complete.  Calculate the final
> C     flux value.
> C
>       IF(SMOOTH1.EQ.1) THEN
> C       Find the near-neighbor flux.
>         DISNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>         RETURN
>       ELSE IF(SMOOTH1.EQ.2) THEN
> C       Calculate the distance weighted sum of the flux and NUMBIN
> C       values.
> C
>         FLUX = 0.0
>         DISNUM = 0.0
>         DTOT = 0.0
>         DO I = 1,IUSE
>           DTOT = DTOT + RNGUSE(I)
>           J = IUSE - I + 1
>           WEIGHT = RNGUSE(J)
>           IF(LOGFLG.EQ.1) THEN
>             FLUX   = FLUX   + LOG10(FLXUSE(I))*WEIGHT
>           ELSE
>             FLUX   = FLUX   + FLXUSE(I)*WEIGHT
>           END IF
>           DISNUM = DISNUM + FLOAT(NUMUSE(I))*WEIGHT
>         END DO
> C
>         FLUX = FLUX/DTOT
>         DISNUM = DISNUM/DTOT
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>       ELSE
> C       Get average flux.
>         FLUX = 0.0
>         DISNUM = 0.0
>         DO I = 1,IUSE
>           IF(LOGFLG.EQ.1) THEN
>             FLUX   = FLUX   + LOG10(FLXUSE(I))
>           ELSE
>             FLUX   = FLUX   + FLXUSE(I)
>           END IF
>           DISNUM = DISNUM + FLOAT(NUMUSE(I))
>         END DO
>         FLUX = FLUX/FLOAT(IUSE)
>         DISNUM = DISNUM/FLOAT(IUSE)
> D       WRITE(*,*)' SMOOTH1! DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $                       DISNUM,RNGCELL,NUMCELL,FLUX
>       END IF
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
>       RNGCELL = RNGUSE(1)
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT2_MAP_Z!!'
> D     WRITE(*,*)' DISNUM,RNGCELL,NUMCELL,FLUX = ',
> D    $            DISNUM,RNGCELL,NUMCELL,FLUX
> D     WRITE(*,*)
> C
>       RETURN 
>       END
> C
> C
>       SUBROUTINE FLXDAT3(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $  FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,FLUX,AVGNUM,
>      $  RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with the specified number of high and low
> C     flux values inside the volume dropped first.
> C
> C     INPUTS:
> C       IKP     - Kp interval index (1 -> MAXKP).
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
> C       NUMDAT  - number of non-zero values in the database.
> C       XFLUX   - array containing the X-coordinate of each data
> C                 cell's center  (Re).
> C       YFLUX   - array containing the Y-coordinate of each data
> C                 cell's center  (Re).
> C       ZFLUX   - array containing the Z-coordinate of each data
> C                 cell's center  (Re).
> C       FLUXBIN - array containing the average ion flux within
> C                 each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN  - array containing the number of non-zero values within
> C                 each cell.
> C       RNGCHK  - the range tolerance variable (Re).
> C       NDROPHI - number of high flux values to drop for smoothing
> C                  filter.
> C
> C       NDROPLO - number of low flux values to drop for smoothing
> C                  filter.
> C
> C       LOGFLG  - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C
> C     OUTPUTS:
> C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM  - average number of flux values per cell used to get FLUX.
> C       RNGCELL - distance to center of flux database cell used  (Re).
> C       NUMCELL - number of flux database cells used that have the
> C                 same value of RNGCELL.
> C
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXCELL.PAR'
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT3!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,NDROPHI,NDROPLO = ',
> D    $            LOGFLG,RNGCHK,NDROPHI,NDROPLO
> D     PAUSE
> C
> C     Find the nearest non-zero data cell.  Use its flux value.
> C
>       IF(XGSM.GE.0.) THEN
> C       Do not use Z-layers on the dayside of the magnetosphere.
>         ZCKLO = -7.
>         ZCKHI = +100.
>       ELSE
> C       Use the nearest neighbor flux only inside a range of Z-values.
>         IF(ZGSM.LE.-6.) THEN
> C         Use the nearest neighbor in the -7 < Z < -6. range.
>           ZCKLO = -7.
>           ZCKHI = -6.
>         ELSE IF((ZGSM.GT.-6.).AND.(ZGSM.LE.-5.)) THEN
> C         Use the nearest neighbor in the -6 < Z < -5. range.
>           ZCKLO = -6.
>           ZCKHI = -5.
>         ELSE IF((ZGSM.GT.-5.).AND.(ZGSM.LE.+4.)) THEN
> C         Use the nearest neighbor in the -5 < Z < +4. range.
>           ZCKLO = -5.
>           ZCKHI = +4.
>         ELSE IF((ZGSM.GT.+4.).AND.(ZGSM.LE.+5.)) THEN
> C         Use the nearest neighbor in the +4 < Z < +5. range.
>           ZCKLO = +4.
>           ZCKHI = +5.
>         ELSE IF((ZGSM.GT.+5.).AND.(ZGSM.LE.+6.)) THEN
> C         Use the nearest neighbor in the +5 < Z < +6. range.
>           ZCKLO = +5.
>           ZCKHI = +6.
>         ELSE IF((ZGSM.GT.+6.).AND.(ZGSM.LE.+7.)) THEN
> C         Use the nearest neighbor in the +6 < Z < +7. range.
>           ZCKLO = +6.
>           ZCKHI = +7.
>         ELSE IF((ZGSM.GT.+7.).AND.(ZGSM.LE.+8.)) THEN
> C         Use the nearest neighbor in the +7 < Z < +8. range.
>           ZCKLO = +7.
>           ZCKHI = +8.
>         ELSE IF((ZGSM.GT.+8.).AND.(ZGSM.LE.+9.)) THEN
> C         Use the nearest neighbor in the +8 < Z < +9. range.
>           ZCKLO = +8.
>           ZCKHI = +9.
>         ELSE IF((ZGSM.GT.+9.).AND.(ZGSM.LE.+10.)) THEN
> C         Use the nearest neighbor in the +9 < Z < +10. range.
>           ZCKLO = +9.
>           ZCKHI = +10.
>         ELSE IF(ZGSM.GT.+10.) THEN
> C         Use the nearest neighbor in the +10 < Z < +11. range.
>           ZCKLO = +10.
>           ZCKHI = +11.
>         END IF
>       END IF
> C
> D     WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
>       DO I = 1,NUMDAT(IKP)
>         IF((FLUXBIN(IKP,I) .GT.1.).AND.(ZFLUX(IKP,I).GT.ZCKLO)
>      $     .AND.(ZFLUX(IKP,I).LE.ZCKHI)) THEN
>           RNG = SQRT((XFLUX(IKP,I)-XGSM)**2 + (YFLUX(IKP,I)-YGSM)**2
>      $      + (ZFLUX(IKP,I)-ZGSM)**2)
> D         WRITE(*,*)' I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),',
> D    $              'ZFLUX(IKP,I) = ',
> D    $                I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),
> D    $               ZFLUX(IKP,I)
> D         WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
>           RNGDIFF = RNG - RNGCELL
>           RNGABS = ABS(RNGDIFF)
>           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C           There is a new nearest neighbor data cell.
>             NUMCELL = 1
>             RNGCELL = RNG
>             RNGSTO(1) = RNG
>             FLXSTO(1) = FLUXBIN(IKP,I)
>             NUMSTO(1) = NUMBIN(IKP,I)
>           ELSE IF(RNGABS.LE.RNGCHK) THEN
> C           There is a new data cell within the range
> C           tolerance to the nearest neighbor.  This cell's flux
> C           should be included in the average for this location.
>             NUMCELL = NUMCELL + 1
>             RNGSTO(NUMCELL) = RNG
>             FLXSTO(NUMCELL) = FLUXBIN(IKP,I)
>             NUMSTO(NUMCELL) = NUMBIN(IKP,I)
>             IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>           END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       NDO = NUMCELL
>       DO J =1,NDROPHI
> C
> C       Find the index of the high flux value data cell.
> C
>         FLXMAX = 0.0
>         DO I = 1,NDO
>           IF(FLXSTO(I).GE.FLXMAX) THEN
>             FLXMAX = FLXSTO(I)
>             INDMAX = I
>           END IF
>         END DO
> D       WRITE(*,*)' J,NDO,INDMAX,FLXMAX = ',J,NDO,INDMAX,FLXMAX
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMAX) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
> D           WRITE(*,*)' J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),',
> D    $                 'NUMUSE(IUSE) = ',
> D    $                  J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER HIGH INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       NDO = IUSE
>       DO J =1,NDROPLO
> C
> C       Find the index of the low flux value data cell.
> C
>         FLXMIN = 1.E+25
>         DO I = 1,NDO
>           IF(FLXSTO(I).LE.FLXMIN) THEN
>             FLXMIN = FLXSTO(I)
>             INDMIN = I
>           END IF
>         END DO
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMIN) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER LOW INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(I))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT3!!'
> D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT3_MAP(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,NSPHVOL,
>      $  IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with the specified number of high and low
> C     flux values inside the volume dropped first.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       NDROPHI  - number of high flux values to drop for smoothing
> C                  filter.
> C
> C       NDROPLO  - number of low flux values to drop for smoothing
> C                  filter.
> C
> C       LOGFLG   - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C
> C     OUTPUTS:
> C       FLUX     - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM   - average number of flux values per cell used to get FLUX.
> C       RNGCELL  - distance to center of flux database cell used  (Re).
> C       NUMCELL  - number of flux database cells used that have the
> C                  same value of RNGCELL.
> C
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT3_MAP!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,NDROPHI,NDROPLO = ',
> D    $            LOGFLG,RNGCHK,NDROPHI,NDROPLO
> D     PAUSE
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             XVE = XFLUX(IKP,INDEXNOW)
>             YVE = YFLUX(IKP,INDEXNOW)
>             ZVE = ZFLUX(IKP,INDEXNOW)
>             RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>             RNGDIFF = RNG - RNGCELL
>             RNGABS = ABS(RNGDIFF)
> D           WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D           WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D           WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>             IF(NUMCELL.EQ.0) THEN
> CCC         IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C             There is a new nearest neighbor data cell.
>               NUMCELL = 1
> D             WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>               RNGCELL = RNG
>               RNGSTO(1) = RNG
>               FLXSTO(1) = FVE
>               NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>             ELSE 
>               IF(RNGABS.LE.RNGCHK) THEN
> C               There is a new data cell within the range
> C               tolerance to the nearest neighbor.  This cell's flux
> C               should be included in the average for this location.
>                 NUMCELL = NUMCELL + 1
>                 RNGSTO(NUMCELL) = RNG
> D               WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                 FLXSTO(NUMCELL) = FVE
>                 NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                 IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>               ELSE
>                 GO TO 1000
>               END IF
>             END IF
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       NDO = NUMCELL
>       DO J =1,NDROPHI
> C
> C       Find the index of the high flux value data cell.
> C
>         FLXMAX = 0.0
>         DO I = 1,NDO
>           IF(FLXSTO(I).GE.FLXMAX) THEN
>             FLXMAX = FLXSTO(I)
>             INDMAX = I
>           END IF
>         END DO
> D       WRITE(*,*)' J,NDO,INDMAX,FLXMAX = ',J,NDO,INDMAX,FLXMAX
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMAX) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
> D           WRITE(*,*)' J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),',
> D    $                 'NUMUSE(IUSE) = ',
> D    $                  J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER HIGH INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       NDO = IUSE
>       DO J =1,NDROPLO
> C
> C       Find the index of the low flux value data cell.
> C
>         FLXMIN = 1.E+25
>         DO I = 1,NDO
>           IF(FLXSTO(I).LE.FLXMIN) THEN
>             FLXMIN = FLXSTO(I)
>             INDMIN = I
>           END IF
>         END DO
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMIN) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER LOW INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(I))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT3_MAP!!'
> D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT3_MAP_Z(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,NSPHVOL,
>      $  IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with the specified number of high and low
> C     flux values inside the volume dropped first.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       NDROPHI  - number of high flux values to drop for smoothing
> C                  filter.
> C
> C       NDROPLO  - number of low flux values to drop for smoothing
> C                  filter.
> C
> C       LOGFLG   - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C
> C     OUTPUTS:
> C       FLUX     - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM   - average number of flux values per cell used to get FLUX.
> C       RNGCELL  - distance to center of flux database cell used  (Re).
> C       NUMCELL  - number of flux database cells used that have the
> C                  same value of RNGCELL.
> C
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT3_MAP_Z!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,NDROPHI,NDROPLO = ',
> D    $            LOGFLG,RNGCHK,NDROPHI,NDROPLO
> D     PAUSE
> C
> C     Get the limits on z-values used to search for near-neighbors.
> C
>       CALL ZBINNER(XGSM,ZGSM,ZCKLO,ZCKHI)
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             ZVE = ZFLUX(IKP,INDEXNOW)
> D           WRITE(*,*)' ZGSM,ZVE,ZCKLO,ZCKHI = ',ZGSM,ZVE,ZCKLO,ZCKHI
> D           PAUSE 'PAUSED!'
>             IF((ZVE.GE.ZCKLO).AND.(ZVE.LE.ZCKHI)) THEN
>               XVE = XFLUX(IKP,INDEXNOW)
>               YVE = YFLUX(IKP,INDEXNOW)
>               RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>               RNGDIFF = RNG - RNGCELL
>               RNGABS = ABS(RNGDIFF)
> D             WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D             WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D             WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>               IF(NUMCELL.EQ.0) THEN
> CCC           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C               There is a new nearest neighbor data cell.
>                 NUMCELL = 1
> D               WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>                 RNGCELL = RNG
>                 RNGSTO(1) = RNG
>                 FLXSTO(1) = FVE
>                 NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>               ELSE 
>                 IF(RNGABS.LE.RNGCHK) THEN
> C                 There is a new data cell within the range
> C                 tolerance to the nearest neighbor.  This cell's flux
> C                 should be included in the average for this location.
>                   NUMCELL = NUMCELL + 1
>                   RNGSTO(NUMCELL) = RNG
> D                 WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                   FLXSTO(NUMCELL) = FVE
>                   NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                   IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>                 ELSE
>                   GO TO 1000
>                 END IF
>               END IF
>             END IF
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       NDO = NUMCELL
>       DO J =1,NDROPHI
> C
> C       Find the index of the high flux value data cell.
> C
>         FLXMAX = 0.0
>         DO I = 1,NDO
>           IF(FLXSTO(I).GE.FLXMAX) THEN
>             FLXMAX = FLXSTO(I)
>             INDMAX = I
>           END IF
>         END DO
> D       WRITE(*,*)' J,NDO,INDMAX,FLXMAX = ',J,NDO,INDMAX,FLXMAX
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMAX) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
> D           WRITE(*,*)' J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),',
> D    $                 'NUMUSE(IUSE) = ',
> D    $                  J,I,IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER HIGH INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       NDO = IUSE
>       DO J =1,NDROPLO
> C
> C       Find the index of the low flux value data cell.
> C
>         FLXMIN = 1.E+25
>         DO I = 1,NDO
>           IF(FLXSTO(I).LE.FLXMIN) THEN
>             FLXMIN = FLXSTO(I)
>             INDMIN = I
>           END IF
>         END DO
> C
> C       Save the IUSE data cells' information to the work arrays.
> C
>         IUSE = 0
>         DO I = 1,NDO
>           IF(I.NE.INDMIN) THEN
>             IUSE = IUSE + 1
>             RNGUSE(IUSE) = RNGSTO(I)
>             FLXUSE(IUSE) = FLXSTO(I)
>             NUMUSE(IUSE) = NUMSTO(I)
>             FLXSTO(IUSE) = FLXUSE(IUSE)
>           END IF
>         END DO
>       END DO
> C
> D     WRITE(*,*)' AFTER LOW INDEX!  IUSE = ',IUSE
> D     DO I = 1,IUSE
> D       WRITE(*,*)' RNGUSE(I),FLXUSE(I),NUMUSE(I) = ',
> D    $              RNGUSE(I),FLXUSE(I),NUMUSE(I)
> D     END DO
> D     PAUSE
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(I))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT3_MAP_Z!!'
> D     WRITE(*,*)' RNGCELL,FLUX = ',RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT4(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $  FLUXBIN,NUMBIN,RNGCHK,LOGFLG,FPCHI,FPCLO,FLUX,AVGNUM,
>      $  RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with percentile threshold limits on flux
> C     values.
> C
> C     INPUTS:
> C       IKP     - Kp interval index (1 -> MAXKP).
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
> C       NUMDAT  - number of non-zero values in the database.
> C       XFLUX   - array containing the X-coordinate of each data
> C                 cell's center  (Re).
> C       YFLUX   - array containing the Y-coordinate of each data
> C                 cell's center  (Re).
> C       ZFLUX   - array containing the Z-coordinate of each data
> C                 cell's center  (Re).
> C       FLUXBIN - array containing the average ion flux within
> C                 each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN  - array containing the number of non-zero values within
> C                 each cell.
> C       RNGCHK  - the range tolerance variable (Re).
> C       LOGFLG  - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C       FPCHI   - upper percentile limit for spatial averaging of flux
> C       FPCLO   - lower percentile limit for spatial averaging of flux
> C
> C     OUTPUTS:
> C       FLUX    - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM  - average number of flux values per cell used to get FLUX.
> C       RNGCELL - distance to center of flux database cell used  (Re).
> C       NUMCELL - number of flux database cells used that have the
> C                 same value of RNGCELL.
> C
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXCELL.PAR'
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
>       INTEGER FPCHI,FPCLO
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT4!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,FPCHI,FPCLO = ',
> D    $            LOGFLG,RNGCHK,FPCHI,FPCLO
> D     PAUSE
> C
> C     Find the nearest non-zero data cell.  Use its flux value.
> C
>       IF(XGSM.GE.0.) THEN
> C       Do not use Z-layers on the dayside of the magnetosphere.
>         ZCKLO = -7.
>         ZCKHI = +100.
>       ELSE
> C       Use the nearest neighbor flux only inside a range of Z-values.
>         IF(ZGSM.LE.-6.) THEN
> C         Use the nearest neighbor in the -7 < Z < -6. range.
>           ZCKLO = -7.
>           ZCKHI = -6.
>         ELSE IF((ZGSM.GT.-6.).AND.(ZGSM.LE.-5.)) THEN
> C         Use the nearest neighbor in the -6 < Z < -5. range.
>           ZCKLO = -6.
>           ZCKHI = -5.
>         ELSE IF((ZGSM.GT.-5.).AND.(ZGSM.LE.+4.)) THEN
> C         Use the nearest neighbor in the -5 < Z < +4. range.
>           ZCKLO = -5.
>           ZCKHI = +4.
>         ELSE IF((ZGSM.GT.+4.).AND.(ZGSM.LE.+5.)) THEN
> C         Use the nearest neighbor in the +4 < Z < +5. range.
>           ZCKLO = +4.
>           ZCKHI = +5.
>         ELSE IF((ZGSM.GT.+5.).AND.(ZGSM.LE.+6.)) THEN
> C         Use the nearest neighbor in the +5 < Z < +6. range.
>           ZCKLO = +5.
>           ZCKHI = +6.
>         ELSE IF((ZGSM.GT.+6.).AND.(ZGSM.LE.+7.)) THEN
> C         Use the nearest neighbor in the +6 < Z < +7. range.
>           ZCKLO = +6.
>           ZCKHI = +7.
>         ELSE IF((ZGSM.GT.+7.).AND.(ZGSM.LE.+8.)) THEN
> C         Use the nearest neighbor in the +7 < Z < +8. range.
>           ZCKLO = +7.
>           ZCKHI = +8.
>         ELSE IF((ZGSM.GT.+8.).AND.(ZGSM.LE.+9.)) THEN
> C         Use the nearest neighbor in the +8 < Z < +9. range.
>           ZCKLO = +8.
>           ZCKHI = +9.
>         ELSE IF((ZGSM.GT.+9.).AND.(ZGSM.LE.+10.)) THEN
> C         Use the nearest neighbor in the +9 < Z < +10. range.
>           ZCKLO = +9.
>           ZCKHI = +10.
>         ELSE IF(ZGSM.GT.+10.) THEN
> C         Use the nearest neighbor in the +10 < Z < +11. range.
>           ZCKLO = +10.
>           ZCKHI = +11.
>         END IF
>       END IF
> C
> D     WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
>       DO I = 1,NUMDAT(IKP)
>         IF((FLUXBIN(IKP,I) .GT.1.).AND.(ZFLUX(IKP,I).GT.ZCKLO)
>      $     .AND.(ZFLUX(IKP,I).LE.ZCKHI)) THEN
>           RNG = SQRT((XFLUX(IKP,I)-XGSM)**2 + (YFLUX(IKP,I)-YGSM)**2
>      $      + (ZFLUX(IKP,I)-ZGSM)**2)
> D         WRITE(*,*)' I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),',
> D    $              'ZFLUX(IKP,I) = ',
> D    $                I,FLUXBIN(IKP,I),XFLUX(IKP,I),YFLUX(IKP,I),
> D    $               ZFLUX(IKP,I)
> D         WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
>           RNGDIFF = RNG - RNGCELL
>           RNGABS = ABS(RNGDIFF)
>           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C           There is a new nearest neighbor data cell.
>             NUMCELL = 1
>             RNGCELL = RNG
>             RNGSTO(1) = RNG
>             FLXSTO(1) = FLUXBIN(IKP,I)
>             NUMSTO(1) = NUMBIN(IKP,I)
>           ELSE IF(RNGABS.LE.RNGCHK) THEN
> C           There is a new data cell within the range
> C           tolerance to the nearest neighbor.  This cell's flux
> C           should be included in the average for this location.
>             NUMCELL = NUMCELL + 1
>             RNGSTO(NUMCELL) = RNG
>             FLXSTO(NUMCELL) = FLUXBIN(IKP,I)
>             NUMSTO(NUMCELL) = NUMBIN(IKP,I)
>             IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>           END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       if (numcell.eq.0) then
>          flux = 0.0
>          avgnum = 0.0
>          return
>       end if
> C     Calculate the flux statistics for the values inside this volume.
>       CALL STATFLX(NUMCELL,RNGSTO,NUMSTO,FLXSTO,FPCHI,FPCLO,FMEAN,FLXHI,
>      $  FLXLO,FSIG,FMAX,FMIN)
> C
> D     WRITE(*,*)' FPCHI,FPCLO,FLXHI,FLXLO = ',FPCHI,FPCLO,FLXHI,FLXLO
> D     DO I = 1,NUMCELL
> D       WRITE(*,*)' I,RNGSTO(I),NUMSTO(I),FLXSTO(I) = ',
> D    $              I,RNGSTO(I),NUMSTO(I),FLXSTO(I)
> D     END DO
> C
> C     Throw out flux values in the table that are above FLXHI or
> C     below FLXLO.
> C
>       IUSE = 0
>       DO I = 1,NUMCELL
>         IF((FLXSTO(I).LT.FLXHI).AND.(FLXSTO(I).GT.FLXLO)) THEN
> C         Use this flux value to perform spatial averaging.
>           IUSE = IUSE + 1
>           RNGUSE(IUSE) = RNGSTO(I)
>           FLXUSE(IUSE) = FLXSTO(I)
>           NUMUSE(IUSE) = NUMSTO(I)
> D         WRITE(*,*)' IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE) = ',
> D    $                IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>         END IF
>       END DO
> C
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(1))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT4!!'
> D     WRITE(*,*)' NUMCELL,AVGNUM,RNGCELL,FLUX = ',
> D    $            NUMCELL,AVGNUM,RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT4_MAP(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,LOGFLG,NSPHVOL,IOFFSET,JOFFSET,
>      $  KOFFSET,IMAPINDX,FPCHI,FPCLO,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with percentile threshold limits on flux
> C     values.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       LOGFLG   - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C       FPCHI    - upper percentile limit for spatial averaging of flux
> C       FPCLO    - lower percentile limit for spatial averaging of flux
> C
> C     OUTPUTS:
> C       FLUX     - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM   - average number of flux values per cell used to get FLUX.
> C       RNGCELL  - distance to center of flux database cell used  (Re).
> C       NUMCELL  - number of flux database cells used that have the
> C                  same value of RNGCELL.
> C
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
>       INTEGER FPCHI,FPCLO
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT4_MAP!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,FPCHI,FPCLO = ',
> D    $            LOGFLG,RNGCHK,FPCHI,FPCLO
> D     PAUSE
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             XVE = XFLUX(IKP,INDEXNOW)
>             YVE = YFLUX(IKP,INDEXNOW)
>             ZVE = ZFLUX(IKP,INDEXNOW)
>             RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>             RNGDIFF = RNG - RNGCELL
>             RNGABS = ABS(RNGDIFF)
> D           WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D           WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D           WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>             IF(NUMCELL.EQ.0) THEN
> CCC         IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C             There is a new nearest neighbor data cell.
>               NUMCELL = 1
> D             WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>               RNGCELL = RNG
>               RNGSTO(1) = RNG
>               FLXSTO(1) = FVE
>               NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>             ELSE 
>               IF(RNGABS.LE.RNGCHK) THEN
> C               There is a new data cell within the range
> C               tolerance to the nearest neighbor.  This cell's flux
> C               should be included in the average for this location.
>                 NUMCELL = NUMCELL + 1
>                 RNGSTO(NUMCELL) = RNG
> D               WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                 FLXSTO(NUMCELL) = FVE
>                 NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                 IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>               ELSE
>                 GO TO 1000
>               END IF
>             END IF
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       if (numcell.eq.0) then
>          flux = 0.0
>          avgnum = 0.0
>          return
>       end if
> C     Calculate the flux statistics for the values inside this volume.
>       CALL STATFLX(NUMCELL,RNGSTO,NUMSTO,FLXSTO,FPCHI,FPCLO,FMEAN,FLXHI,
>      $  FLXLO,FSIG,FMAX,FMIN)
> C
> D     WRITE(*,*)' FPCHI,FPCLO,FLXHI,FLXLO = ',FPCHI,FPCLO,FLXHI,FLXLO
> D     DO I = 1,NUMCELL
> D       WRITE(*,*)' I,RNGSTO(I),NUMSTO(I),FLXSTO(I) = ',
> D    $              I,RNGSTO(I),NUMSTO(I),FLXSTO(I)
> D     END DO
> C
> C     Throw out flux values in the table that are above FLXHI or
> C     below FLXLO.
> C
>       IUSE = 0
>       DO I = 1,NUMCELL
>         IF((FLXSTO(I).LT.FLXHI).AND.(FLXSTO(I).GT.FLXLO)) THEN
> C         Use this flux value to perform spatial averaging.
>           IUSE = IUSE + 1
>           RNGUSE(IUSE) = RNGSTO(I)
>           FLXUSE(IUSE) = FLXSTO(I)
>           NUMUSE(IUSE) = NUMSTO(I)
> D         WRITE(*,*)' IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE) = ',
> D    $                IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>         END IF
>       END DO
> C
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(1))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT4_MAP!!'
> D     WRITE(*,*)' NUMCELL,AVGNUM,RNGCELL,FLUX = ',
> D    $            NUMCELL,AVGNUM,RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE FLXDAT4_MAP_Z(IKP,XGSM,YGSM,ZGSM,NUMDAT,XFLUX,YFLUX,
>      $  ZFLUX,FLUXBIN,NUMBIN,RNGCHK,LOGFLG,NSPHVOL,IOFFSET,JOFFSET,
>      $  KOFFSET,IMAPINDX,FPCHI,FPCLO,FLUX,AVGNUM,RNGCELL,NUMCELL)
> C
> C     This routine finds the flux corresponding to the satellite's
> C     GSM position coordinates by use of the GEOTAIL database.
> C
> C     This routine is used to calculate the spatial average of flux in a
> C     volume given by RNGCHK, with percentile threshold limits on flux
> C     values.
> C
> C     INPUTS:
> C       IKP      - Kp interval index (1 -> MAXKP).
> C       XGSM     - satellite's X-coordinate (Re).
> C       YGSM     - satellite's Y-coordinate (Re).
> C       ZGSM     - satellite's Z-coordinate (Re).
> C       NUMDAT   - number of non-zero values in the database.
> C       XFLUX    - array containing the X-coordinate of each data
> C                  cell's center  (Re).
> C       YFLUX    - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
> C       ZFLUX    - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
> C       FLUXBIN  - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
> C       NUMBIN   - array containing the number of non-zero values within
> C                  each cell.
> C       RNGCHK   - the range tolerance variable (Re).
> C       LOGFLG   - flag controlling how flux average is performed
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
> C       FPCHI    - upper percentile limit for spatial averaging of flux
> C       FPCLO    - lower percentile limit for spatial averaging of flux
> C
> C     OUTPUTS:
> C       FLUX     - computed average flux value  (ions/[cm^2-sec-sr-MeV]).
> C       AVGNUM   - average number of flux values per cell used to get FLUX.
> C       RNGCELL  - distance to center of flux database cell used  (Re).
> C       NUMCELL  - number of flux database cells used that have the
> C                  same value of RNGCELL.
> C
>       INCLUDE 'MAXCELL.PAR'
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'NSAVE.PAR'
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'MAXNSPHVOL.PAR'
>       INCLUDE 'StreamLineGeo.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       REAL FLXSTO(MAXCELL),RNGSTO(MAXCELL)
>       INTEGER NUMSTO(MAXCELL)
> C
>       REAL FLXUSE(MAXCELL),RNGUSE(MAXCELL)
>       INTEGER NUMUSE(MAXCELL)
> C
>       INTEGER FPCHI,FPCLO
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' ENTERED FLXDAT4_MAP_Z!!'
> D     WRITE(*,*)' IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1) = ',
> D    $            IKP,NUMDAT(1),XFLUX(1,1),YFLUX(1,1)
> D     WRITE(*,*)' ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1) = ',
> D    $            ZFLUX(1,1),FLUXBIN(1,1),NUMBIN(1,1)
> D     WRITE(*,*)' XGSM,YGSM,ZGSM = ',XGSM,YGSM,ZGSM
> D     WRITE(*,*)' LOGFLG,RNGCHK,FPCHI,FPCLO = ',
> D    $            LOGFLG,RNGCHK,FPCHI,FPCLO
> D     PAUSE
> C
> C
> C     Get the limits on z-values used to search for near-neighbors.
> C
>       CALL ZBINNER(XGSM,ZGSM,ZCKLO,ZCKHI)
> C
> C     Calculate the index for this S/C position.
> C
>       INDX = INT((XGSM - XMIN)/XINC) + 1
>       INDY = INT((YGSM - YMIN)/YINC) + 1
>       INDZ = INT((ZGSM - ZMIN)/ZINC) + 1
> D     WRITE(*,*)' INDX,INDY,INDZ = ',INDX,INDY,INDZ
> C
>       RNGCELL = 1.E+25
>       NUMCELL = 0
> C
>       DO I = 1,NSPHVOL
>         II = INDX + IOFFSET(I)
>         JJ = INDY + JOFFSET(I)
>         KK = INDZ + KOFFSET(I)
>         if ((ii.ge.1).and.(jj.ge.1).and.(kk.ge.1).and.(ii.le.maxnum)
>      $  .and.(jj.le.maxnum).and.(kk.le.maxnum)) then
>         INDEXNOW = IMAPINDX(IKP,II,JJ,KK)
> D       WRITE(*,*)' I,II,JJ,KK,INDEXNOW = ',I,II,JJ,KK,INDEXNOW
>         IF(INDEXNOW.GT.0) THEN
>           FVE = FLUXBIN(IKP,INDEXNOW)
> D         WRITE(*,*)' I,FVE = ',I,FVE
> C
>           IF(FVE .GT.0.) THEN
>             ZVE = ZFLUX(IKP,INDEXNOW)
> D           WRITE(*,*)' ZGSM,ZVE,ZCKLO,ZCKHI = ',ZGSM,ZVE,ZCKLO,ZCKHI
> D           PAUSE 'PAUSED!'
>             IF((ZVE.GE.ZCKLO).AND.(ZVE.LE.ZCKHI)) THEN
>               XVE = XFLUX(IKP,INDEXNOW)
>               YVE = YFLUX(IKP,INDEXNOW)
>               RNG = SQRT((XVE-XGSM)**2 + (YVE-YGSM)**2 + (ZVE-ZGSM)**2)
>               RNGDIFF = RNG - RNGCELL
>               RNGABS = ABS(RNGDIFF)
> D             WRITE(*,*)' I,FVE,XVE,YVE,ZVE = ',I,FVE,XVE,YVE,ZVE
> D             WRITE(*,*)' I,RNG,RNGCELL = ',I,RNG,RNGCELL
> D             WRITE(*,*)' I,RNGDIFF,RNGABS = ',I,RNGDIFF,RNGABS
>               IF(NUMCELL.EQ.0) THEN
> CCC           IF((RNGABS.GT.RNGCHK).AND.(RNGDIFF.LT.0.0)) THEN
> C               There is a new nearest neighbor data cell.
>                 NUMCELL = 1
> D               WRITE(*,*)' #1: I,NUMCELL = ',I,NUMCELL
>                 RNGCELL = RNG
>                 RNGSTO(1) = RNG
>                 FLXSTO(1) = FVE
>                 NUMSTO(1) = NUMBIN(IKP,INDEXNOW)
>               ELSE 
>                 IF(RNGABS.LE.RNGCHK) THEN
> C                 There is a new data cell within the range
> C                 tolerance to the nearest neighbor.  This cell's flux
> C                 should be included in the average for this location.
>                   NUMCELL = NUMCELL + 1
>                   RNGSTO(NUMCELL) = RNG
> D                 WRITE(*,*)' #2: I,NUMCELL = ',I,NUMCELL
>                   FLXSTO(NUMCELL) = FVE
>                   NUMSTO(NUMCELL) = NUMBIN(IKP,INDEXNOW)
>                   IF(NUMCELL.EQ.MAXCELL) GO TO 1000
>                 ELSE
>                   GO TO 1000
>                 END IF
>               END IF
>             END IF
>           END IF
>         END IF
>         END IF
>       END DO
> C
> 1000  CONTINUE
> C
>       if (numcell.eq.0) then
>          flux = 0.0
>          avgnum = 0.0
>          return
>       end if
> C     Calculate the flux statistics for the values inside this volume.
>       CALL STATFLX(NUMCELL,RNGSTO,NUMSTO,FLXSTO,FPCHI,FPCLO,FMEAN,FLXHI,
>      $  FLXLO,FSIG,FMAX,FMIN)
> C
> D     WRITE(*,*)' FPCHI,FPCLO,FLXHI,FLXLO = ',FPCHI,FPCLO,FLXHI,FLXLO
> D     DO I = 1,NUMCELL
> D       WRITE(*,*)' I,RNGSTO(I),NUMSTO(I),FLXSTO(I) = ',
> D    $              I,RNGSTO(I),NUMSTO(I),FLXSTO(I)
> D     END DO
> C
> C     Throw out flux values in the table that are above FLXHI or
> C     below FLXLO.
> C
>       IUSE = 0
>       DO I = 1,NUMCELL
>         IF((FLXSTO(I).LT.FLXHI).AND.(FLXSTO(I).GT.FLXLO)) THEN
> C         Use this flux value to perform spatial averaging.
>           IUSE = IUSE + 1
>           RNGUSE(IUSE) = RNGSTO(I)
>           FLXUSE(IUSE) = FLXSTO(I)
>           NUMUSE(IUSE) = NUMSTO(I)
> D         WRITE(*,*)' IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE) = ',
> D    $                IUSE,RNGUSE(IUSE),FLXUSE(IUSE),NUMUSE(IUSE)
>         END IF
>       END DO
> C
> C
>       IF(IUSE.LE.1) THEN
> C       There is only one data cell.
>         AVGNUM = FLOAT(NUMUSE(1))
>         RNGCELL = RNGUSE(1)
>         NUMCELL = 1
>         FLUX = FLXUSE(1)
>         RETURN
>       END IF
> C
> C     Get average flux.
>       FLUX = 0.0
>       AVGNUM = 0.0
>       RNGCELL = 0.0
>       DO I = 1,IUSE
>         IF(LOGFLG.EQ.1) THEN
>           FLUX   = FLUX   + LOG10(FLXUSE(I))
>         ELSE
>           FLUX   = FLUX   + FLXUSE(I)
>         END IF
>         AVGNUM = AVGNUM + FLOAT(NUMUSE(1))
>         RNGCELL = RNGCELL + RNGUSE(I)
>       END DO
>       FLUX = FLUX/FLOAT(IUSE)
>       AVGNUM = AVGNUM/FLOAT(IUSE)
>       RNGCELL = RNGCELL/FLOAT(IUSE)
> C
>       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
>       NUMCELL = IUSE
> C
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' END FLXDAT4_MAP_Z!!'
> D     WRITE(*,*)' NUMCELL,AVGNUM,RNGCELL,FLUX = ',
> D    $            NUMCELL,AVGNUM,RNGCELL,FLUX
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE LOCATE(XN_PD,VEL,XGSM,YGSM,ZGSM,XMGNP,YMGNP,ZMGNP,DIST,
>      *  ID)
> C
> C     THIS SUBROUTINE DEFINES THE POSITION OF A POINT (XMGNP,YMGNP,ZMGNP)
> C            AT THE MODEL MAGNETOPAUSE, CLOSEST TO A GIVEN POINT OF SPACE
> C               (XGSM,YGSM,ZGSM),   AND THE DISTANCE BETWEEN THEM (DIST)
> C
> C INPUT:  XN_PD - EITHER SOLAR WIND PROTON NUMBER DENSITY (PER C.C.) (IF VEL>0)
> C                    OR THE SOLAR WIND RAM PRESSURE IN NANOPASCALS   (IF VEL<0)
> C         VEL - EITHER SOLAR WIND VELOCITY (KM/SEC)
> C                  OR ANY NEGATIVE NUMBER, WHICH INDICATES THAT XN_PD STANDS
> C                     FOR THE SOLAR WIND PRESSURE, RATHER THAN FOR THE DENSITY
> C
> C         XGSM,YGSM,ZGSM - COORDINATES OF THE OBSERVATION POINT IN EARTH RADII
> C
> C  OUTPUT: XMGNP,YMGNP,ZMGNP - COORDINATES OF A POINT AT THE MAGNETOPAUSE,
> C                                    CLOSEST TO THE POINT  XGSM,YGSM,ZGSM
> C          DIST -  THE DISTANCE BETWEEN THE ABOVE TWO POINTS, IN RE,
> C          ID -    INDICATOR; ID=+1 AND ID=-1 MEAN THAT THE POINT
> C                       (XGSM,YGSM,ZGSM)  LIES INSIDE OR OUTSIDE
> C                        THE MODEL MAGNETOPAUSE, RESPECTIVELY
> C
> C   THE PRESSURE-DEPENDENT MAGNETOPAUSE IS THAT USED IN THE T96_01 MODEL
> C
> c            CODED BY:  N.A. TSYGANENKO, AUG.1, 1995;  REVISED  JUNE 22, 1996
> C
>       IF (VEL.LT.0.) THEN
>        PD=XN_PD
>                   ELSE
>        PD=1.94E-6*XN_PD*VEL**2  ! PD IS THE SOLAR WIND DYNAMIC PRESSURE
> C                                      (IN NANOPASCALS)
>       ENDIF
> C
>       RAT=PD/2.0  ! RATIO OF PD TO THE AVERAGE PRESSURE, ASSUMED AS 2 nPa
> C
>       RAT16=RAT**0.14 ! THE POWER IN THE SCALING FACTOR IS THE BEST-FIT VALUE
> C                         OBTAINED FROM DATA IN THE T96_01 VERSION OF THE MODEL
> C
>       A0=70.
>       S00=1.08
>       X00=5.48    !  VALUES OF THE MAGNETOPAUSE PARAMETERS FOR  PD = 2 nPa
> C
>       A=A0/RAT16
>       S0=S00
>       X0=X00/RAT16   !  VALUES OF THE MAGNETOPAUSE PARAMETERS, SCALED TO THE
> C                         ACTUAL PRESSURE
> C
>        XM=X0-A    !  THIS IS THE X-COORDINATE OF THE "SEAM" BETWEEN THE
> C                             ELLIPSOID AND THE CYLINDER
> C
> C        (FOR DETAILS ON THE ELLIPSOIDAL COORDINATES, SEE THE PAPER:
> C            N.A.TSYGANENKO, SOLUTION OF CHAPMAN-FERRARO PROBLEM FOR AN
> C             ELLIPSOIDAL MAGNETOPAUSE, PLANET.SPACE SCI., V.37, P.1037, 1989).
> C
>           IF (YGSM.NE.0..OR.ZGSM.NE.0.) THEN
>              PHI=ATAN2(YGSM,ZGSM)
>               ELSE
>              PHI=0.
>           ENDIF
> C
>           RHO=SQRT(YGSM**2+ZGSM**2)
> C
>          IF (XGSM.LT.XM) THEN
>            XMGNP=XGSM
>            RHOMGNP=A*SQRT(S0**2-1)
>            YMGNP=RHOMGNP*SIN(PHI)
>            ZMGNP=RHOMGNP*COS(PHI)
>            DIST=SQRT((XGSM-XMGNP)**2+(YGSM-YMGNP)**2+(ZGSM-ZMGNP)**2)
>            IF (RHOMGNP.GT.RHO) ID=+1
>            IF (RHOMGNP.LT.RHO) ID=-1
>            RETURN
>          ENDIF
> C
>           XKSI=(XGSM-X0)/A+1.
>           XDZT=RHO/A
>           SQ1=SQRT((1.+XKSI)**2+XDZT**2)
>           SQ2=SQRT((1.-XKSI)**2+XDZT**2)
>           SIGMA=0.5*(SQ1+SQ2)
>           TAU=0.5*(SQ1-SQ2)
> C
> C  NOW CALCULATE (X,Y,Z) FOR THE CLOSEST POINT AT THE MAGNETOPAUSE
> C
>           XMGNP=X0-A*(1.-S0*TAU)
>           RHOMGNP=A*SQRT((S0**2-1.)*(1.-TAU**2))
>           YMGNP=RHOMGNP*SIN(PHI)
>           ZMGNP=RHOMGNP*COS(PHI)
> C
> C  NOW CALCULATE THE SHORTEST DISTANCE BETWEEN THE POINT XGSM,YGSM,ZGSM AND THE
> C            MAGNETOPAUSE
> C
>       DIST=SQRT((XGSM-XMGNP)**2+(YGSM-YMGNP)**2+(ZGSM-ZMGNP)**2)
> C
>       IF (SIGMA.GT.S0) ID=-1   !  ID=-1 MEANS THAT THE POINT LIES OUTSIDE
>       IF (SIGMA.LT.S0) ID=+1   !  ID=+1 MEANS THAT THE POINT LIES INSIDE
> C                                           THE MAGNETOSPHERE
>       RETURN
>       END
> C
> C
>       SUBROUTINE LOCREG(XKP,XGSM,YGSM,ZGSM,XTAIL,YTAIL,ZTAIL,IDLOC)
> C
> C     This routine determines which phenomenological region the
> C     spacecraft is in.
> C
> C     Input:
> C       XKP     - Kp index (real value between 0 & 9).
> C       XGSM    - satellite's X-coordinate (Re).
> C       YGSM    - satellite's Y-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
> C
> C     Outputs:
> C       XTAIL   - satellite's X-coordinate in geotail system (Re).
> C       YTAIL   - satellite's Y-coordinate in geotail system (Re).
> C       ZTAIL   - satellite's Z-coordinate in geotail system (Re).
> C       IDLOC   - phenomenogical region location identification flag:
> C                 IDLOC = 1 if spacecraft is in solar wind
> C                 IDLOC = 2 if spacecraft is in magnetosheath
> C                 IDLOC = 3 if spacecraft is in magnetosphere
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' Entered LOCREG!'
> D     WRITE(*,*)' XKP,XGSM,YGSM,ZGSM = ',
> D    $            XKP,XGSM,YGSM,ZGSM
> D     PAUSE
> C
> C     Set the region identification flag to "no region".
>       IDLOC = 0
> C
> C     Get the solar wind parameters used as inputs for the bow shock
> C     and magnetopause boundary models for this value of Kp.
> C
>       CALL SOLWIND(XKP,BX,BY,BZ,VX,VY,VZ,DENNUM,SWETEMP,SWPTEMP,
>      $  HEFRAC,SWHTEMP,BOWANG,DYPRES,ABANG,XHINGE)
> C
> C     Transform the spacecraft's coordinates to a system aligned
> C     with the geotail.
> C     Rotate the bow shock by the aberration angle.
>       ANGRAD = -ABANG * 0.01745329252
>       CALL ROT8ANG(ANGRAD,XGSM,YGSM,XHINGE,XTAIL,YTAIL)
>       ZTAIL = ZGSM
> C
> C     Determine if the spacecraft is inside the magnetosphere.  Use the
> C     Tsyganenko magnetopause model.
> C
>       VEL = -1.
>       CALL LOCATE(DYPRES,VEL,XTAIL,YTAIL,ZTAIL,XMGP,YMGP,ZMGP,DIST,ID)
> C
>       IF(ID.EQ.+1) THEN
> C       The spacecraft is inside the magnetosphere.
>         IDLOC = 3
>       ELSE
> C       Determine if the spacecraft is in either the solar wind or
> C       the magnetosheath.  Calculate the bow shock radius at this point.
> C
>         CALL BOWSHK2(BX,BY,BZ,VX,VY,VZ,DENNUM,SWETEMP,SWPTEMP,HEFRAC,
>      $    SWHTEMP,XTAIL,BOWANG,RADBS)
> C
> C       Find the distance of the spacecraft from the aberrated x-axis.
>         DISTSC = SQRT(YTAIL**2 + ZTAIL**2)
> C
>         IF(DISTSC.LE.RADBS) THEN
> C         The spacecraft is in the magnetosheath.
>           IDLOC = 2
>         ELSE
> C         The spacecraft is in the solar wind.
>           IDLOC = 1
>         END IF
>       END IF
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE MAPSPHERE(DISTMAPMAX,XINC,YINC,ZINC,NSPHVOL,
>      $  IOFFSET,JOFFSET,KOFFSET)
> C
> C     This routine finds the (I,J,K) index offset values which are
> C     used to define the search volume for the near-neighbor flux
> C     search.
> C
> C     INPUTS:
> C       DISTMAPMAX - maximum distance from flux measurement location
> C                     allowed for streamline mapping (Re).
> C       XINC       - extent of database cell in X-direction (Re).
> C       YINC       - extent of database cell in Y-direction (Re).
> C       ZINC       - extent of database cell in Z-direction (Re).
> C
> C     OUTPUTS:
> C       NSPHVOL    - number of volume elements stored in the
> C                    database search volume.
> C       IOFFSET    - array of offset indices for X-direction.
> C       JOFFSET    - array of offset indices for Y-direction.
> C       KOFFSET    - array of offset indices for Z-direction.
> C
> C     *** NOTE *** The indices are sorted by range from the center of
> C     the spherical search volume (ascending order on range).
> C
>       INCLUDE 'MAXNSPHVOL.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL)
>       REAL RNGOFFSET(MAXNSPHVOL)
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' Entered MAPSPHERE!'
> D     WRITE(*,*)' DISTMAPMAX = ',DISTMAPMAX
> D     WRITE(*,*)' MAXNSPHVOL = ',MAXNSPHVOL
> D     WRITE(*,*)' XINC,YINC,ZINC = ',XINC,YINC,ZINC
> D     PAUSE 'PAUSED!'
> C
> C     Open files to store the unsorted and sorted offset indices.
> D     OPEN(15,FILE='OFFSET_UNSORTED.DAT',ACCESS='SEQUENTIAL',
> D    $  FORM='FORMATTED',STATUS='UNKNOWN')
> D     OPEN(16,FILE='OFFSET_SORTED.DAT',ACCESS='SEQUENTIAL',
> D    $  FORM='FORMATTED',STATUS='UNKNOWN')
> C
> C     Get the number of volume bins that extends 1/2 the length
> C     of each side of the cube which contains the spherical search
> C     volume defined by DISTMAPMAX.
>       ISTEP = DISTMAPMAX/XINC
>       JSTEP = DISTMAPMAX/YINC
>       KSTEP = DISTMAPMAX/ZINC
> D     WRITE(*,*)' ISTEP,JSTEP,KSTEP = ',ISTEP,JSTEP,KSTEP
> C
> C     Store the index offset values for each volume element that
> C     lies within the search volume sphere.
> C
>       ISTRT = - ISTEP
>       JSTRT = - JSTEP
>       KSTRT = - KSTEP
>       ISTOP = + ISTEP
>       JSTOP = + JSTEP
>       KSTOP = + KSTEP
> D     WRITE(*,*)' ISTRT,JSTRT,KSTRT = ',ISTRT,JSTRT,KSTRT
> D     WRITE(*,*)' ISTOP,JSTOP,KSTOP = ',ISTOP,JSTOP,KSTOP
> D     PAUSE 'PAUSED!'
> C
>       NSPHVOL = 0
> C
>       DO I = ISTRT,ISTOP
>         DO J = JSTRT,JSTOP
>           DO K = KSTRT,KSTOP
> C           Calculate the distance of this volume element from the
> C           search volume's central volume element.
>             XRNG = I*XINC
>             YRNG = J*YINC
>             ZRNG = K*ZINC
>             DIST = SQRT(XRNG**2 + YRNG**2 + ZRNG**2)
> D           WRITE(*,*)' I,J,K,XRNG,YRNG,ZRNG,DIST = ',
> D    $                  I,J,K,XRNG,YRNG,ZRNG,DIST
> D           PAUSE 'PAUSED!'
>             IF(DIST.LE.DISTMAPMAX) THEN
> C             Store this volume element's indices as part of the
> C             spherical search volume.
>               NSPHVOL = NSPHVOL + 1
>               IF(NSPHVOL.GT.MAXNSPHVOL) THEN
>                 WRITE(*,*)
>                 WRITE(*,*)' NSPHVOL.GT.MAXNSPHVOL!'
>                 PAUSE 'PAUSED!'
>                 STOP 41
>               END IF
>               RNGOFFSET(NSPHVOL) = DIST
>               IOFFSET(NSPHVOL) = I
>               JOFFSET(NSPHVOL) = J
>               KOFFSET(NSPHVOL) = K
> D             WRITE(*,*)' I,J,K,XRNG,YRNG,ZRNG,DIST = ',
> D    $                    I,J,K,XRNG,YRNG,ZRNG,DIST
> D             WRITE(*,*)' NSPHVOL,RNGOFFSET(NSPHVOL) = ',
> D    $                    NSPHVOL,RNGOFFSET(NSPHVOL)
> D             WRITE(*,*)' NSPHVOL,IOFFSET(NSPHVOL) = ',
> D    $                    NSPHVOL,IOFFSET(NSPHVOL)
> D             WRITE(*,*)' NSPHVOL,JOFFSET(NSPHVOL) = ',
> D    $                    NSPHVOL,JOFFSET(NSPHVOL)
> D             WRITE(*,*)' NSPHVOL,KOFFSET(NSPHVOL) = ',
> D    $                    NSPHVOL,KOFFSET(NSPHVOL)
> D             WRITE(15,*)' I,J,K,XRNG,YRNG,ZRNG,DIST = ',
> D    $                     I,J,K,XRNG,YRNG,ZRNG,DIST
> D             WRITE(15,*)' NSPHVOL,RNGOFFSET(NSPHVOL) = ',
> D    $                     NSPHVOL,RNGOFFSET(NSPHVOL)
> D             WRITE(15,*)' NSPHVOL,IOFFSET(NSPHVOL) = ',
> D    $                     NSPHVOL,IOFFSET(NSPHVOL)
> D             WRITE(15,*)' NSPHVOL,JOFFSET(NSPHVOL) = ',
> D    $                     NSPHVOL,JOFFSET(NSPHVOL)
> D             WRITE(15,*)' NSPHVOL,KOFFSET(NSPHVOL) = ',
> D    $                     NSPHVOL,KOFFSET(NSPHVOL)
>             END IF
>           END DO
>         END DO
>       END DO
> D     CLOSE(15)
> C
> C     Sort the offset index arrays in ascending by geocentric range
> C     from the center of the search volume.
> C
>       CALL SORTRNGINDEX(NSPHVOL,RNGOFFSET,IOFFSET,JOFFSET,KOFFSET)
> C
> D     WRITE(*,*)' NSPHVOL = ',NSPHVOL
> D     PAUSE 'PAUSED!'
> D     DO I = 1,NSPHVOL
> D       WRITE(*,*)' I,RNGOFFSET(I) = ',
> D    $              I,RNGOFFSET(I)
> D       WRITE(*,*)' I,IOFFSET(I) = ',
> D    $              I,IOFFSET(I)
> D       WRITE(*,*)' I,JOFFSET(I) = ',
> D    $              I,JOFFSET(I)
> D       WRITE(*,*)' I,KOFFSET(I) = ',
> D    $              I,KOFFSET(I)
> D       WRITE(16,*)' I,RNGOFFSET(I) = ',
> D    $               I,RNGOFFSET(I)
> D       WRITE(16,*)' I,IOFFSET(I) = ',
> D    $               I,IOFFSET(I)
> D       WRITE(16,*)' I,JOFFSET(I) = ',
> D    $               I,JOFFSET(I)
> D       WRITE(16,*)' I,KOFFSET(I) = ',
> D    $               I,KOFFSET(I)
> D     END DO
> D     CLOSE(16)
> D     PAUSE 'PAUSED!'
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE MSHEFLX(XKP,ISPECI,FLUXMN,FLUX95,FLUX50,FLUXSD)
> C
> C     This routine provides the magnetosheath ion flux as a function
> C     of Kp.
> C
> C     Input:
> C       XKP     - Kp index (real value between 0 & 9).
> C       ISPECI  - ion species selection flag
> C                 ISPECI = 1 for protons
> C                 ISPECI = 2 for Helium
> C                 ISPECI = 3 for CNO
> C
> C     Output:
> C       FLUXMN  - mean flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX95  - 95% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX50  - 50% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUXSD  - standard deviation of flux for selected species.
> C
>       IF(ISPECI.EQ.1) THEN
> C       Provide proton flux values.
>         IF(XKP.LE.4.5) THEN
>           FLUXMN = 7.161418E-3*XKP**2 + 2.831376E-1*XKP + 2.57324
>         ELSE
>           FLUXMN = 2.28935E-1*XKP + 2.94481
>         END IF
>         A = EXP(1.227335)
>         FLUX95 = A*XKP**2.076779E-1
>         FLUX50 = 6.674753E-3*XKP**3 - 9.069930E-2*XKP**2
>      $         + 6.807628E-1*XKP + 1.231926
>         FLUXSD = 1.347388E-1*XKP + 3.671634
> C
>         FLUXMN = 10**FLUXMN
>         FLUX95 = 10**FLUX95
>         FLUX50 = 10**FLUX50
>         FLUXSD = 10**FLUXSD
>       ELSE IF(ISPECI.EQ.2) THEN
> C       Provide helium flux values.
>         FLUXMN = -1.E-11
>         FLUX95 = -1.E-11
>         FLUX50 = -1.E-11
>         FLUXSD = -1.E-11
>       ELSE IF(ISPECI.EQ.3) THEN
> C       Provide CNO flux values.
>         FLUXMN = -1.E-11
>         FLUX95 = -1.E-11
>         FLUX50 = -1.E-11
>         FLUXSD = -1.E-11
>       END IF
> C
>       RETURN
>       END
> C
> C
>       SUBROUTINE NBRFLUX(XKP,NSECTRS,SECTX,SECTY,SCMEAN,SC95,SC50,
>      $  SCSIG,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,FLUXBIN,
>      $  NUMBIN,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,LOGFLG,RNGTOL,FPCHI,
>      $  FPCLO,FLUXMN,FLUX95,FLUX50,FLUXSD)
> C
> C     This routine provides the region's ion flux as a function
> C     of Kp.
> C
> C     Inputs:
> C       XKP     - Kp index (real value between 0 & 9).
> C
> C       NSECTRS - number of Kp scaling sectors in region.
> C
> C       SECTX   - array of each sector center's x coordinate.
> C
> C       SECTY   - array of each sector center's y coordinate.
> C
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C
> C       SC95    - array of each sector's 95% flux scale factor.
> C
> C       SC50    - array of each sector's 50% flux scale factor.
> C
> C       SCSIG   - array of each sector's std dev flux scale factor.
> C
> C       XTAIL   - satellite's X-coordinate in geotail system (Re).
> C
> C       YTAIL   - satellite's Y-coordinate in geotail system (Re).
> C
> C       ZTAIL   - satellite's Z-coordinate in geotail system (Re).
> C
> C       NUMDAT  - number of non-zero values in the database.
> C
> C       XFLUX   - array containing the X-coordinate of each data
> C                 cell's center  (Re).
> C
> C       YFLUX   - array containing the Y-coordinate of each data
> C                 cell's center  (Re).
> C
> C       ZFLUX   - array containing the Z-coordinate of each data
> C                 cell's center  (Re).
> C
> C       FLUXBIN - array containing the average ion flux within
> C                 each cell  (ions/[cm^2-sec-sr-MeV]).
> C
> C       NUMBIN  - array containing the number of non-zero values within
> C                 each cell.
> C
> C       SMOOTH1 - flag for control of database smoothing filter:
> C              SMOOTH1 = 0 if no data smoothing is used.
> C              SMOOTH1 = 1 if spike rejection and near neighbor flux.
> C              SMOOTH1 = 2 if spike rejection with range weighted
> C                           scaling of flux.
> C              SMOOTH1 = 3 if spike rejection with average flux.
> C              SMOOTH1 = 4 if spatial average of flux in volume
> C                           specified by RNGTOL.
> C              SMOOTH1 = 5 if spatial average of flux in volume
> C                           specified by RNGTOL, with the specified
> C                           number of high and low flux values inside
> C                           the volume dropped first.
> C              SMOOTH1 = 6 if spatial averaging of flux in volume
> C                           specified by RNGTOL, with percentile
> C                           threshold limits on flux values.
> C
> C       NFLXGET - number of flux values to get for smoothing filter
> C                  (used if SMOOTH1 = 1,2, or 3)
> C
> C       NDROPHI - number of high flux values to drop for smoothing
> C                  filter (used if SMOOTH1 = 1,2,3, or 5).
> C
> C       NDROPLO - number of low flux values to drop for smoothing
> C                  filter (used if SMOOTH1 = 1,2,3, or 5).
> C
> C       LOGFLG  - flag controlling how flux average is performed
> C                  (used if SMOOTH1 = 2,3,4,5, or 6).
> C              LOGFLG = 1 if log10 of flux values used.
> C              LOGFLG = 2 if linear flux values used.
> C
> C       RNGTOL  - range tolerance from near-neigbor used in spatial
> C                  averaging of database (Re)
> C                  (used if SMOOTH1 = 4,5, or 6).
> C
> C       FPCHI   - upper percentile limit for spatial averaging of flux
> C                  (used if SMOOTH1 = 6).
> C
> C       FPCLO   - lower percentile limit for spatial averaging of flux
> C                  (used if SMOOTH1 = 6).
> C
> C     Output:
> C       FLUXMN  - mean flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX95  - 95% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX50  - 50% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUXSD  - standard deviation of flux for selected species.
> C
> C     Set the minimum range for magnetosphere calculations.
>       PARAMETER (RNGGEO = 6.0)
> C
> C     Set the number of Kp scaling sectors to use per calculation.
> C     (NUMSCAL must not exceed NUMSEC!)
>       PARAMETER (NUMSCAL = 2)
> C
>       INCLUDE 'NUMSEC.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXPNT.PAR'
> C
>       REAL SECTX(NUMSEC),SECTY(NUMSEC)
>       REAL SCMEAN(NUMSEC,MAXKP),SC95(NUMSEC,MAXKP)
>       REAL SC50(NUMSEC,MAXKP),SCSIG(NUMSEC,MAXKP)
>       REAL WTMEAN(MAXKP),WT95(MAXKP),WT50(MAXKP),WTSIG(MAXKP)
>       REAL RNGSECT(NUMSEC),FLUX(MAXKP),AVGNUM(MAXKP),RNGCELL(MAXKP)
>       INTEGER INDSECT(NUMSEC),NUMCELL(MAXKP)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       INTEGER SMOOTH1,FPCHI,FPCLO
> C
> D     WRITE(*,*)
> D     WRITE(*,*)' Entered NBRFLUX!'
> D     WRITE(*,*)' XKP = ',XKP
> D     DO I = 1,NSECTRS
> D       WRITE(*,*)
> D       WRITE(*,*)' I,SECTX(I),SECTY(I) = ',I,SECTX(I),SECTY(I)
> D       DO J = 1,MAXKP
> D         WRITE(*,*)' I,J,SCMEAN(I,J),SC95(I,J) = ',
> D    $                I,J,SCMEAN(I,J),SC95(I,J)
> D         WRITE(*,*)' I,J,SC50(I,J),SCSIG(I,J) = ',
> D    $                I,J,SC50(I,J),SCSIG(I,J)
> D       END DO
> D     END DO
> D     WRITE(*,*)
> D     WRITE(*,*)' XTAIL,YTAIL,ZTAIL = ',XTAIL,YTAIL,ZTAIL
> D     WRITE(*,*)
> D     DO I = 1,MAXKP
> D       WRITE(*,*)' I,NUMDAT(I) = ',I,NUMDAT(I)
> D       DO J = 1,MAXPNT
> D         IF((XFLUX(I,J).GE.-15.).AND.(XFLUX(I,J).LE.-5.).AND.
> D    $       (YFLUX(I,J).GE.-30.).AND.(YFLUX(I,J).LE.-20.)) THEN
> D           WRITE(*,*)' I,J,XFLUX(I,J),YFLUX(I,J),ZFLUX(I,J) = ',
> D    $                  I,J,XFLUX(I,J),YFLUX(I,J),ZFLUX(I,J)
> D           WRITE(*,*)' I,J,NUMBIN(I,J),FLUXBIN(I,J) = ',
> D    $                  I,J,NUMBIN(I,J),FLUXBIN(I,J)
> D           WRITE(*,*)
> D           PAUSE 'PAUSED!'
> D         END IF
> D       END DO
> D     END DO
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
> C
> C     Do not allow for calculations to take place inside the minimum
> C     sphere, which is needed because of GEOTAIL's orbit.
> C
>       RNGCK = SQRT(XTAIL**2 + YTAIL**2 + ZTAIL**2)
>       IF(RNGCK.LT.RNGGEO) THEN
> D       WRITE(*,*)
> D       WRITE(*,*)' Entered magnetosphere data gap region!'
>         FLUXMN = 0.
>         FLUX95 = 0.
>         FLUX50 = 0.
>         FLUXSD = 0.
>         RETURN
>       END IF
> C
> C     Rank order the Kp scaling sectors on the basis of their range
> C     from the satellite in the XY-plane.
> C
>       CALL NEIGHBR(XTAIL,YTAIL,NSECTRS,SECTX,SECTY,INDSECT,RNGSECT)
> D     WRITE(*,*)' After NEIGHBR!'
> D     DO I = 1,NSECTRS
> D       WRITE(*,*)' I,INDSECT(I),RNGSECT(I) = ',I,INDSECT(I),RNGSECT(I)
> D     END DO
> D     WRITE(*,*)
> C
> C     Calculate the distance weighted sum of the Kp scaling factors.
> C
> C     NUMWT = NUMSCAL
>       CALL WTSCAL(XTAIL,YTAIL,NUMSCAL,INDSECT,RNGSECT,SCMEAN,SC95,
>      $  SC50,SCSIG,WTMEAN,WT95,WT50,WTSIG)
> CC    CALL WTSCAL2(NUMSCAL,INDSECT,RNGSECT,SCMEAN,SC95,
> CC   $  SC50,SCSIG,WTMEAN,WT95,WT50,WTSIG)
> D     WRITE(*,*)' After WTSCAL!'
> C
> C     Find the near-neighbor flux data cell for each Kp interval.
> C     These flux values are treated as the average flux at the center
> C     their respective Kp intervals.
> C
> C     Fix the range tolerance for the near-neighbor flux calculation.
>       RNGCHK = 1.0
> C
>       DO I = 1,MAXKP
>         IF((SMOOTH1.EQ.0).OR.(SMOOTH1.EQ.4)) THEN
> C         Calculate the flux with no data smoothing or with spatial
> C         averaging inside the volume defined by RNGTOL.
>           CALL FLXDAT1(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $      FLUXBIN,NUMBIN,RNGCHK,FLUX(I),AVGNUM(I),RNGCELL(I),
>      $      NUMCELL(I))
>         ELSE IF((SMOOTH1.EQ.1).OR.(SMOOTH1.EQ.2).OR.(SMOOTH1.EQ.3)) THEN
> C         Spike rejection option.
>           CALL FLXDAT2(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $      FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $      LOGFLG,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I))
>         ELSE IF(SMOOTH1.EQ.5) THEN
> C         Perform the spatial average inside the volume defined by
> C         RNGTOL after the specified number of high & low flux values
> C         inside the volume have been dropped.
>           CALL FLXDAT3(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $      FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,FLUX(I),
>      $      AVGNUM(I),RNGCELL(I),NUMCELL(I))
>         ELSE
> C         (SMOOTH1 = 6 case) Perform spatial averaging of flux in the
> C         volume specified by RNGTOL, with percentile threshold limits
> C         on flux values used in averaging.
>           CALL FLXDAT4(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $      FLUXBIN,NUMBIN,RNGCHK,LOGFLG,FPCHI,FPCLO,FLUX(I),AVGNUM(I),
>      $      RNGCELL(I),NUMCELL(I))
>         END IF
> D       WRITE(*,*)' After FLUXDAT!'
> D       WRITE(*,*)' I,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I) = ',
> D    $              I,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I)
>       END DO
> C
> C     Find the minimum distance to a data cell from any one of the
> C     database's Kp intervals.
> C
>       RNG1 = RNGMIN1(MAXKP,RNGCELL)
> D     WRITE(*,*)' After RNGMIN!'
> C
> C     Get the weighted sum (average) of all of the useable flux values
> C     that lie within the specified range tolerance above the minimum
> C     range. Get the flux statistics by multiplying the average flux
> C     value at the spacecraft's location by the distance weighted sum
> C     of the Kp scaling factors.
> C
>       IF((SMOOTH1.EQ.4).OR.(SMOOTH1.EQ.5).OR.(SMOOTH1.EQ.6)) THEN
> C       Spatial averaging is used.
>         RNGCHK = RNGTOL
>       ELSE
> C       There is no data smoothing used.
>         RNGCHK = 1.0
>       END IF
> C
>       TOTNUM = 0.
>       FLUXMN = 0.
>       FLUX95 = 0.
>       FLUX50 = 0.
>       FLUXSD = 0.
>       RNG2 = RNG1 + RNGCHK
> C
>       ANNDIST = 0.
>       DO I = 1,MAXKP
>         IF(RNGCELL(I).LE.RNG2) THEN
>           ANNDIST = ANNDIST + RNGCELL(I)*AVGNUM(I)
>           FLUXMN = FLUXMN + FLUX(I)*AVGNUM(I)*WTMEAN(I)
> D         WRITE(*,*)' I,RNGCELL(I),RNG2,FLUXMN,AVGNUM(I),WTMEAN(I) = ',
> D    $                I,RNGCELL(I),RNG2,FLUXMN,AVGNUM(I),WTMEAN(I)
>           FLUX95 = FLUX95 + FLUX(I)*AVGNUM(I)*WT95(I)
>           FLUX50 = FLUX50 + FLUX(I)*AVGNUM(I)*WT50(I)
>           FLUXSD = FLUXSD + FLUX(I)*AVGNUM(I)*WTSIG(I)
>           TOTNUM = TOTNUM + AVGNUM(I)
> D         WRITE(*,*)' I,TOTNUM = ',I,TOTNUM
2008,2009d4822
<         AVGNUM = AVGNUM + FLOAT(NUMUSE(1))
<         RNGCELL = RNGCELL + RNGUSE(I)
2011,2016d4823
<       FLUX = FLUX/FLOAT(IUSE)
<       AVGNUM = AVGNUM/FLOAT(IUSE)
<       RNGCELL = RNGCELL/FLOAT(IUSE)
< C
<       IF(LOGFLG.EQ.1) FLUX = 10.**FLUX
<       NUMCELL = IUSE
2017a4825,4826
>       IF(TOTNUM.LT.1.0) TOTNUM = 1.0
>       ANNDIST = ANNDIST/TOTNUM
2019,2024c4828,4831
< D     WRITE(*,*)
< D     WRITE(*,*)' END FLXDAT4!!'
< D     WRITE(*,*)' NUMCELL,AVGNUM,RNGCELL,FLUX = ',
< D    $            NUMCELL,AVGNUM,RNGCELL,FLUX
< D     WRITE(*,*)
< D     PAUSE 'PAUSED!'
---
>       FLUXMN = FLUXMN/TOTNUM
>       FLUX95 = FLUX95/TOTNUM
>       FLUX50 = FLUX50/TOTNUM
>       FLUXSD = FLUXSD/TOTNUM
2030,2031c4837,4841
<       SUBROUTINE LOCATE(XN_PD,VEL,XGSM,YGSM,ZGSM,XMGNP,YMGNP,ZMGNP,DIST,
<      *  ID)
---
>       SUBROUTINE NBRFLUX_MAP(XKP,NSECTRS,SECTX,SECTY,SCMEAN,SC95,SC50,
>      $  SCSIG,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,FLUXBIN,
>      $  NUMBIN,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,LOGFLG,RNGTOL,FPCHI,
>      $  FPCLO,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUXMN,FLUX95,
>      $  FLUX50,FLUXSD)
2033,2035c4843,4844
< C     THIS SUBROUTINE DEFINES THE POSITION OF A POINT (XMGNP,YMGNP,ZMGNP)
< C            AT THE MODEL MAGNETOPAUSE, CLOSEST TO A GIVEN POINT OF SPACE
< C               (XGSM,YGSM,ZGSM),   AND THE DISTANCE BETWEEN THEM (DIST)
---
> C     This routine provides the region's ion flux as a function
> C     of Kp.
2037,2041c4846,4847
< C INPUT:  XN_PD - EITHER SOLAR WIND PROTON NUMBER DENSITY (PER C.C.) (IF VEL>0)
< C                    OR THE SOLAR WIND RAM PRESSURE IN NANOPASCALS   (IF VEL<0)
< C         VEL - EITHER SOLAR WIND VELOCITY (KM/SEC)
< C                  OR ANY NEGATIVE NUMBER, WHICH INDICATES THAT XN_PD STANDS
< C                     FOR THE SOLAR WIND PRESSURE, RATHER THAN FOR THE DENSITY
---
> C     Inputs:
> C        XKP     - Kp index (real value between 0 & 9).
2043c4849
< C         XGSM,YGSM,ZGSM - COORDINATES OF THE OBSERVATION POINT IN EARTH RADII
---
> C        NSECTRS - number of Kp scaling sectors in region.
2045,2050c4851
< C  OUTPUT: XMGNP,YMGNP,ZMGNP - COORDINATES OF A POINT AT THE MAGNETOPAUSE,
< C                                    CLOSEST TO THE POINT  XGSM,YGSM,ZGSM
< C          DIST -  THE DISTANCE BETWEEN THE ABOVE TWO POINTS, IN RE,
< C          ID -    INDICATOR; ID=+1 AND ID=-1 MEAN THAT THE POINT
< C                       (XGSM,YGSM,ZGSM)  LIES INSIDE OR OUTSIDE
< C                        THE MODEL MAGNETOPAUSE, RESPECTIVELY
---
> C        SECTX   - array of each sector center's x coordinate.
2052c4853
< C   THE PRESSURE-DEPENDENT MAGNETOPAUSE IS THAT USED IN THE T96_01 MODEL
---
> C        SECTY   - array of each sector center's y coordinate.
2054c4855
< c            CODED BY:  N.A. TSYGANENKO, AUG.1, 1995;  REVISED  JUNE 22, 1996
---
> C        SCMEAN  - array of each sector's mean flux scale factor.
2056,2061c4857
<       IF (VEL.LT.0.) THEN
<        PD=XN_PD
<                   ELSE
<        PD=1.94E-6*XN_PD*VEL**2  ! PD IS THE SOLAR WIND DYNAMIC PRESSURE
< C                                      (IN NANOPASCALS)
<       ENDIF
---
> C        SC95    - array of each sector's 95% flux scale factor.
2063c4859
<       RAT=PD/2.0  ! RATIO OF PD TO THE AVERAGE PRESSURE, ASSUMED AS 2 nPa
---
> C        SC50    - array of each sector's 50% flux scale factor.
2065,2066c4861
<       RAT16=RAT**0.14 ! THE POWER IN THE SCALING FACTOR IS THE BEST-FIT VALUE
< C                         OBTAINED FROM DATA IN THE T96_01 VERSION OF THE MODEL
---
> C        SCSIG   - array of each sector's std dev flux scale factor.
2068,2070c4863
<       A0=70.
<       S00=1.08
<       X00=5.48    !  VALUES OF THE MAGNETOPAUSE PARAMETERS FOR  PD = 2 nPa
---
> C        XTAIL   - satellite's X-coordinate in geotail system (Re).
2072,2075c4865
<       A=A0/RAT16
<       S0=S00
<       X0=X00/RAT16   !  VALUES OF THE MAGNETOPAUSE PARAMETERS, SCALED TO THE
< C                         ACTUAL PRESSURE
---
> C        YTAIL   - satellite's Y-coordinate in geotail system (Re).
2077,2078c4867
<        XM=X0-A    !  THIS IS THE X-COORDINATE OF THE "SEAM" BETWEEN THE
< C                             ELLIPSOID AND THE CYLINDER
---
> C        ZTAIL   - satellite's Z-coordinate in geotail system (Re).
2080,2082c4869
< C        (FOR DETAILS ON THE ELLIPSOIDAL COORDINATES, SEE THE PAPER:
< C            N.A.TSYGANENKO, SOLUTION OF CHAPMAN-FERRARO PROBLEM FOR AN
< C             ELLIPSOIDAL MAGNETOPAUSE, PLANET.SPACE SCI., V.37, P.1037, 1989).
---
> C        NUMDAT  - number of non-zero values in the database.
2084,2088c4871,4872
<           IF (YGSM.NE.0..OR.ZGSM.NE.0.) THEN
<              PHI=ATAN2(YGSM,ZGSM)
<               ELSE
<              PHI=0.
<           ENDIF
---
> C        XFLUX   - array containing the X-coordinate of each data
> C                  cell's center  (Re).
2090c4874,4875
<           RHO=SQRT(YGSM**2+ZGSM**2)
---
> C        YFLUX   - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
2092,2101c4877,4878
<          IF (XGSM.LT.XM) THEN
<            XMGNP=XGSM
<            RHOMGNP=A*SQRT(S0**2-1)
<            YMGNP=RHOMGNP*SIN(PHI)
<            ZMGNP=RHOMGNP*COS(PHI)
<            DIST=SQRT((XGSM-XMGNP)**2+(YGSM-YMGNP)**2+(ZGSM-ZMGNP)**2)
<            IF (RHOMGNP.GT.RHO) ID=+1
<            IF (RHOMGNP.LT.RHO) ID=-1
<            RETURN
<          ENDIF
---
> C        ZFLUX   - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
2103,2108c4880,4881
<           XKSI=(XGSM-X0)/A+1.
<           XDZT=RHO/A
<           SQ1=SQRT((1.+XKSI)**2+XDZT**2)
<           SQ2=SQRT((1.-XKSI)**2+XDZT**2)
<           SIGMA=0.5*(SQ1+SQ2)
<           TAU=0.5*(SQ1-SQ2)
---
> C        FLUXBIN - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
2110c4883,4884
< C  NOW CALCULATE (X,Y,Z) FOR THE CLOSEST POINT AT THE MAGNETOPAUSE
---
> C        NUMBIN  - array containing the number of non-zero values within
> C                  each cell.
2112,2115c4886,4900
<           XMGNP=X0-A*(1.-S0*TAU)
<           RHOMGNP=A*SQRT((S0**2-1.)*(1.-TAU**2))
<           YMGNP=RHOMGNP*SIN(PHI)
<           ZMGNP=RHOMGNP*COS(PHI)
---
> C        SMOOTH1 - flag for control of database smoothing filter:
> C               SMOOTH1 = 0 if no data smoothing is used.
> C               SMOOTH1 = 1 if spike rejection and near neighbor flux.
> C               SMOOTH1 = 2 if spike rejection with range weighted
> C                            scaling of flux.
> C               SMOOTH1 = 3 if spike rejection with average flux.
> C               SMOOTH1 = 4 if spatial average of flux in volume
> C                            specified by RNGTOL.
> C               SMOOTH1 = 5 if spatial average of flux in volume
> C                            specified by RNGTOL, with the specified
> C                            number of high and low flux values inside
> C                            the volume dropped first.
> C               SMOOTH1 = 6 if spatial averaging of flux in volume
> C                            specified by RNGTOL, with percentile
> C                            threshold limits on flux values.
2117,2118c4902,4903
< C  NOW CALCULATE THE SHORTEST DISTANCE BETWEEN THE POINT XGSM,YGSM,ZGSM AND THE
< C            MAGNETOPAUSE
---
> C       NFLXGET  - number of flux values to get for smoothing filter
> C                   (used if SMOOTH1 = 1,2, or 3)
2120c4905,4906
<       DIST=SQRT((XGSM-XMGNP)**2+(YGSM-YMGNP)**2+(ZGSM-ZMGNP)**2)
---
> C       NDROPHI  - number of high flux values to drop for smoothing
> C                   filter (used if SMOOTH1 = 1,2,3, or 5).
2122,2126c4908,4909
<       IF (SIGMA.GT.S0) ID=-1   !  ID=-1 MEANS THAT THE POINT LIES OUTSIDE
<       IF (SIGMA.LT.S0) ID=+1   !  ID=+1 MEANS THAT THE POINT LIES INSIDE
< C                                           THE MAGNETOSPHERE
<       RETURN
<       END
---
> C       NDROPLO  - number of low flux values to drop for smoothing
> C                   filter (used if SMOOTH1 = 1,2,3, or 5).
2127a4911,4914
> C       LOGFLG   - flag controlling how flux average is performed
> C                   (used if SMOOTH1 = 2,3,4,5, or 6).
> C               LOGFLG = 1 if log10 of flux values used.
> C               LOGFLG = 2 if linear flux values used.
2129c4916,4918
<       SUBROUTINE LOCREG(XKP,XGSM,YGSM,ZGSM,XTAIL,YTAIL,ZTAIL,IDLOC)
---
> C       RNGTOL   - range tolerance from near-neigbor used in spatial
> C                   averaging of database (Re)
> C                   (used if SMOOTH1 = 4,5, or 6).
2131,2132c4920,4921
< C     This routine determines which phenomenological region the
< C     spacecraft is in.
---
> C       FPCHI    - upper percentile limit for spatial averaging of flux
> C                   (used if SMOOTH1 = 6).
2134,2138c4923,4930
< C     Input:
< C       XKP     - Kp index (real value between 0 & 9).
< C       XGSM    - satellite`s X-coordinate (Re).
< C       YGSM    - satellite`s Y-coordinate (Re).
< C       ZGSM    - satellite`s Z-coordinate (Re).
---
> C       FPCLO    - lower percentile limit for spatial averaging of flux
> C                   (used if SMOOTH1 = 6).
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
2140,2147c4932,4966
< C     Outputs:
< C       XTAIL   - satellite`s X-coordinate in geotail system (Re).
< C       YTAIL   - satellite`s Y-coordinate in geotail system (Re).
< C       ZTAIL   - satellite`s Z-coordinate in geotail system (Re).
< C       IDLOC   - phenomenogical region location identification flag:
< C                 IDLOC = 1 if spacecraft is in solar wind
< C                 IDLOC = 2 if spacecraft is in magnetosheath
< C                 IDLOC = 3 if spacecraft is in magnetosphere
---
> C     Output:
> C       FLUXMN  - mean flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX95  - 95% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUX50  - 50% flux (#/[cm^2-sec-sr-MeV]) for selected species.
> C       FLUXSD  - standard deviation of flux for selected species.
> C
> C     Set the minimum range for magnetosphere calculations.
>       PARAMETER (RNGGEO = 6.0)
> C
> C     Set the number of Kp scaling sectors to use per calculation.
> C     (NUMSCAL must not exceed NUMSEC!)
>       PARAMETER (NUMSCAL = 2)
> C
>       INCLUDE 'NUMSEC.PAR'
>       INCLUDE 'MAXKP.PAR'
>       INCLUDE 'MAXPNT.PAR'
>       INCLUDE 'MAXNUM.PAR'
> C
>       INCLUDE 'MAXNSPHVOL.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
> C
>       REAL SECTX(NUMSEC),SECTY(NUMSEC)
>       REAL SCMEAN(NUMSEC,MAXKP),SC95(NUMSEC,MAXKP)
>       REAL SC50(NUMSEC,MAXKP),SCSIG(NUMSEC,MAXKP)
>       REAL WTMEAN(MAXKP),WT95(MAXKP),WT50(MAXKP),WTSIG(MAXKP)
>       REAL RNGSECT(NUMSEC),FLUX(MAXKP),AVGNUM(MAXKP),RNGCELL(MAXKP)
>       INTEGER INDSECT(NUMSEC),NUMCELL(MAXKP)
> C
>       INTEGER NUMDAT(MAXKP),NUMBIN(MAXKP,MAXPNT)
>       REAL FLUXBIN(MAXKP,MAXPNT),XFLUX(MAXKP,MAXPNT)
>       REAL YFLUX(MAXKP,MAXPNT),ZFLUX(MAXKP,MAXPNT)
> C
>       INTEGER SMOOTH1,FPCHI,FPCLO
2150,2153c4969,4999
< D     WRITE(*,*)' Entered LOCREG!'
< D     WRITE(*,*)' XKP,XGSM,YGSM,ZGSM = ',
< D    $            XKP,XGSM,YGSM,ZGSM
< D     PAUSE
---
> D     WRITE(*,*)' Entered NBRFLUX!'
> D     WRITE(*,*)' XKP = ',XKP
> D     DO I = 1,NSECTRS
> D       WRITE(*,*)
> D       WRITE(*,*)' I,SECTX(I),SECTY(I) = ',I,SECTX(I),SECTY(I)
> D       DO J = 1,MAXKP
> D         WRITE(*,*)' I,J,SCMEAN(I,J),SC95(I,J) = ',
> D    $                I,J,SCMEAN(I,J),SC95(I,J)
> D         WRITE(*,*)' I,J,SC50(I,J),SCSIG(I,J) = ',
> D    $                I,J,SC50(I,J),SCSIG(I,J)
> D       END DO
> D     END DO
> D     WRITE(*,*)
> D     WRITE(*,*)' XTAIL,YTAIL,ZTAIL = ',XTAIL,YTAIL,ZTAIL
> D     WRITE(*,*)
> D     DO I = 1,MAXKP
> D       WRITE(*,*)' I,NUMDAT(I) = ',I,NUMDAT(I)
> D       DO J = 1,MAXPNT
> D         IF((XFLUX(I,J).GE.-15.).AND.(XFLUX(I,J).LE.-5.).AND.
> D    $       (YFLUX(I,J).GE.-30.).AND.(YFLUX(I,J).LE.-20.)) THEN
> D           WRITE(*,*)' I,J,XFLUX(I,J),YFLUX(I,J),ZFLUX(I,J) = ',
> D    $                  I,J,XFLUX(I,J),YFLUX(I,J),ZFLUX(I,J)
> D           WRITE(*,*)' I,J,NUMBIN(I,J),FLUXBIN(I,J) = ',
> D    $                  I,J,NUMBIN(I,J),FLUXBIN(I,J)
> D           WRITE(*,*)
> D           PAUSE 'PAUSED!'
> D         END IF
> D       END DO
> D     END DO
> D     WRITE(*,*)
> D     PAUSE 'PAUSED!'
2155,2156c5001,5002
< C     Set the region identification flag to "no region".
<       IDLOC = 0
---
> C     Do not allow for calculations to take place inside the minimum
> C     sphere, which is needed because of GEOTAIL's orbit.
2158,2159c5004,5013
< C     Get the solar wind parameters used as inputs for the bow shock
< C     and magnetopause boundary models for this value of Kp.
---
>       RNGCK = SQRT(XTAIL**2 + YTAIL**2 + ZTAIL**2)
>       IF(RNGCK.LT.RNGGEO) THEN
> D       WRITE(*,*)
> D       WRITE(*,*)' Entered magnetosphere data gap region!'
>         FLUXMN = 0.
>         FLUX95 = 0.
>         FLUX50 = 0.
>         FLUXSD = 0.
>         RETURN
>       END IF
2161,2162c5015,5016
<       CALL SOLWIND(XKP,BX,BY,BZ,VX,VY,VZ,DENNUM,SWETEMP,SWPTEMP,
<      $  HEFRAC,SWHTEMP,BOWANG,DYPRES,ABANG,XHINGE)
---
> C     Rank order the Kp scaling sectors on the basis of their range
> C     from the satellite in the XY-plane.
2164,2169c5018,5023
< C     Transform the spacecraft`s coordinates to a system aligned
< C     with the geotail.
< C     Rotate the bow shock by the aberration angle.
<       ANGRAD = -ABANG * 0.01745329252
<       CALL ROT8ANG(ANGRAD,XGSM,YGSM,XHINGE,XTAIL,YTAIL)
<       ZTAIL = ZGSM
---
>       CALL NEIGHBR(XTAIL,YTAIL,NSECTRS,SECTX,SECTY,INDSECT,RNGSECT)
> D     WRITE(*,*)' After NEIGHBR!'
> D     DO I = 1,NSECTRS
> D       WRITE(*,*)' I,INDSECT(I),RNGSECT(I) = ',I,INDSECT(I),RNGSECT(I)
> D     END DO
> D     WRITE(*,*)
2171,2172c5025
< C     Determine if the spacecraft is inside the magnetosphere.  Use the
< C     Tsyganenko magnetopause model.
---
> C     Calculate the distance weighted sum of the Kp scaling factors.
2174,2175c5027,5032
<       VEL = -1.
<       CALL LOCATE(DYPRES,VEL,XTAIL,YTAIL,ZTAIL,XMGP,YMGP,ZMGP,DIST,ID)
---
> C     NUMWT = NUMSCAL
>       CALL WTSCAL(XTAIL,YTAIL,NUMSCAL,INDSECT,RNGSECT,SCMEAN,SC95,
>      $  SC50,SCSIG,WTMEAN,WT95,WT50,WTSIG)
> CC    CALL WTSCAL2(NUMSCAL,INDSECT,RNGSECT,SCMEAN,SC95,
> CC   $  SC50,SCSIG,WTMEAN,WT95,WT50,WTSIG)
> D     WRITE(*,*)' After WTSCAL!'
2177,2179c5034,5041
<       IF(ID.EQ.+1) THEN
< C       The spacecraft is inside the magnetosphere.
<         IDLOC = 3
---
> C     Find the near-neighbor flux data cell for each Kp interval.
> C     These flux values are treated as the average flux at the center
> C     their respective Kp intervals.
> C
> C     Fix the range tolerance for the near-neighbor flux calculation.
>       IF((SMOOTH1.EQ.4).OR.(SMOOTH1.EQ.5).OR.(SMOOTH1.EQ.6)) THEN
> C       Spatial averaging is used.
>         RNGCHK = RNGTOL
2181,2182c5043,5045
< C       Determine if the spacecraft is in either the solar wind or
< C       the magnetosheath.  Calculate the bow shock radius at this point.
---
> C       There is no data smoothing used.
>         RNGCHK = 1.0
>       END IF
2184,2185c5047,5054
<         CALL BOWSHK2(BX,BY,BZ,VX,VY,VZ,DENNUM,SWETEMP,SWPTEMP,HEFRAC,
<      $    SWHTEMP,XTAIL,BOWANG,RADBS)
---
> C     Find the index for the current Kp value.
>       DO I = 1,MAXKP
>         IF((XKP.LE.FLOAT(I)).AND.(XKP.GE.FLOAT(I-1))) THEN
>           IKP = I
>           GO TO 1000
>         END IF
>       END DO
> 1000  CONTINUE
2187,2188c5056,5057
< C       Find the distance of the spacecraft from the aberrated x-axis.
<         DISTSC = SQRT(YTAIL**2 + ZTAIL**2)
---
> D     WRITE(*,*)' XKP,IKP = ',XKP,IKP
> D     PAUSE 'PAUSED!'
2190,2196c5059,5086
<         IF(DISTSC.LE.RADBS) THEN
< C         The spacecraft is in the magnetosheath.
<           IDLOC = 2
<         ELSE
< C         The spacecraft is in the solar wind.
<           IDLOC = 1
<         END IF
---
>       IF((SMOOTH1.EQ.0).OR.(SMOOTH1.EQ.4)) THEN
> C       Calculate the flux with no data smoothing or with spatial
> C       averaging inside the volume defined by RNGTOL.
>         CALL FLXDAT1_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $    FLUXBIN,NUMBIN,RNGCHK,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $    IMAPINDX,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP))
>       ELSE IF((SMOOTH1.EQ.1).OR.(SMOOTH1.EQ.2).OR.(SMOOTH1.EQ.3)) THEN
> C       Spike rejection option.
>         CALL FLXDAT2_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $    FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $    LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX(IKP),
>      $    AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP))
>       ELSE IF(SMOOTH1.EQ.5) THEN
> C       Perform the spatial average inside the volume defined by
> C       RNGTOL after the specified number of high & low flux values
> C       inside the volume have been dropped.
>         CALL FLXDAT3_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $    FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,NSPHVOL,
>      $    IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX(IKP),AVGNUM(IKP),
>      $    RNGCELL(IKP),NUMCELL(IKP))
>       ELSE
> C       (SMOOTH1 = 6 case) Perform spatial averaging of flux in the
> C       volume specified by RNGTOL, with percentile threshold limits
> C       on flux values used in averaging.
>         CALL FLXDAT4_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
>      $    FLUXBIN,NUMBIN,RNGCHK,LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $    IMAPINDX,FPCHI,FPCLO,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),
>      $    NUMCELL(IKP))
2197a5088,5091
> D     WRITE(*,*)' After FLUXDAT!'
> D     WRITE(*,*)' IKP,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),',
> D    $           'NUMCELL(IKP) = ',
> D    $            IKP,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP)
2199,2200c5093,5094
<       RETURN
<       END
---
> C     Find the minimum distance to a data cell from any one of the
> C     database's Kp intervals.
2201a5096,5097
>       RNG1 = RNGMIN1(MAXKP,RNGCELL)
> D     WRITE(*,*)' After RNGMIN!'
2203c5099,5103
<       SUBROUTINE MSHEFLX(XKP,ISPECI,FLUXMN,FLUX95,FLUX50,FLUXSD)
---
> C     Get the weighted sum (average) of all of the useable flux values
> C     that lie within the specified range tolerance above the minimum
> C     range. Get the flux statistics by multiplying the average flux
> C     value at the spacecraft's location by the distance weighted sum
> C     of the Kp scaling factors.
2205,2206c5105,5108
< C     This routine provides the magnetosheath ion flux as a function
< C     of Kp.
---
>       FLUXMN = 0.
>       FLUX95 = 0.
>       FLUX50 = 0.
>       FLUXSD = 0.
2208,2213d5109
< C     Input:
< C       XKP     - Kp index (real value between 0 & 9).
< C       ISPECI  - ion species selection flag
< C                 ISPECI = 1 for protons
< C                 ISPECI = 2 for Helium
< C                 ISPECI = 3 for CNO
2215,2219c5111,5121
< C     Output:
< C       FLUXMN  - mean flux (#/[cm^2-sec-sr-MeV]) for selected species.
< C       FLUX95  - 95% flux (#/[cm^2-sec-sr-MeV]) for selected species.
< C       FLUX50  - 50% flux (#/[cm^2-sec-sr-MeV]) for selected species.
< C       FLUXSD  - standard deviation of flux for selected species.
---
>       ANNDIST = RNGCELL(IKP)*AVGNUM(IKP)
>       FLUXMN = FLUXMN + FLUX(IKP)*AVGNUM(IKP)*WTMEAN(IKP)
> D     WRITE(*,*)' XKP,XTAIL,YTAIL,ZTAIL = ',XKP,XTAIL,YTAIL,ZTAIL
> D     WRITE(*,*)' IKP,FLUX(IKP),RNGCELL(IKP),RNG2 = ',
> D    $            IKP,FLUX(IKP),RNGCELL(IKP),RNG2
> D     WRITE(*,*)' FLUXMN,AVGNUM(IKP),WTMEAN(IKP) = ',
> D    $            FLUXMN,AVGNUM(IKP),WTMEAN(IKP)
>       FLUX95 = FLUX95 + FLUX(IKP)*AVGNUM(IKP)*WT95(IKP)
>       FLUX50 = FLUX50 + FLUX(IKP)*AVGNUM(IKP)*WT50(IKP)
>       FLUXSD = FLUXSD + FLUX(IKP)*AVGNUM(IKP)*WTSIG(IKP)
>       TOTNUM = AVGNUM(IKP)
2221,2232c5123,5124
<       IF(ISPECI.EQ.1) THEN
< C       Provide proton flux values.
<         IF(XKP.LE.4.5) THEN
<           FLUXMN = 7.161418E-3*XKP**2 + 2.831376E-1*XKP + 2.57324
<         ELSE
<           FLUXMN = 2.28935E-1*XKP + 2.94481
<         END IF
<         A = EXP(1.227335)
<         FLUX95 = A*XKP**2.076779E-1
<         FLUX50 = 6.674753E-3*XKP**3 - 9.069930E-2*XKP**2
<      $         + 6.807628E-1*XKP + 1.231926
<         FLUXSD = 1.347388E-1*XKP + 3.671634
---
>       IF(TOTNUM.LT.1.0) TOTNUM = 1.0
>       ANNDIST = ANNDIST/TOTNUM
2234,2250c5126,5131
<         FLUXMN = 10**FLUXMN
<         FLUX95 = 10**FLUX95
<         FLUX50 = 10**FLUX50
<         FLUXSD = 10**FLUXSD
<       ELSE IF(ISPECI.EQ.2) THEN
< C       Provide helium flux values.
<         FLUXMN = -1.E-11
<         FLUX95 = -1.E-11
<         FLUX50 = -1.E-11
<         FLUXSD = -1.E-11
<       ELSE IF(ISPECI.EQ.3) THEN
< C       Provide CNO flux values.
<         FLUXMN = -1.E-11
<         FLUX95 = -1.E-11
<         FLUX50 = -1.E-11
<         FLUXSD = -1.E-11
<       END IF
---
>       FLUXMN = FLUXMN/TOTNUM
> D     WRITE(*,*)' IKP,TOTNUM,FLUXMN = ',IKP,TOTNUM,FLUXMN
> D     WRITE(*,*)
>       FLUX95 = FLUX95/TOTNUM
>       FLUX50 = FLUX50/TOTNUM
>       FLUXSD = FLUXSD/TOTNUM
2256c5137
<       SUBROUTINE NBRFLUX(XKP,NSECTRS,SECTX,SECTY,SCMEAN,SC95,SC50,
---
>       SUBROUTINE NBRFLUX_MAP_Z(XKP,NSECTRS,SECTX,SECTY,SCMEAN,SC95,SC50,
2259c5140,5141
<      $  FPCLO,FLUXMN,FLUX95,FLUX50,FLUXSD)
---
>      $  FPCLO,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUXMN,FLUX95,
>      $  FLUX50,FLUXSD)
2261c5143
< C     This routine provides the region`s ion flux as a function
---
> C     This routine provides the region's ion flux as a function
2265c5147
< C       XKP     - Kp index (real value between 0 & 9).
---
> C        XKP     - Kp index (real value between 0 & 9).
2267c5149
< C       NSECTRS - number of Kp scaling sectors in region.
---
> C        NSECTRS - number of Kp scaling sectors in region.
2269c5151
< C       SECTX   - array of each sector center`s x coordinate.
---
> C        SECTX   - array of each sector center's x coordinate.
2271c5153
< C       SECTY   - array of each sector center`s y coordinate.
---
> C        SECTY   - array of each sector center's y coordinate.
2273c5155
< C       SCMEAN  - array of each sector`s mean flux scale factor.
---
> C        SCMEAN  - array of each sector's mean flux scale factor.
2275c5157
< C       SC95    - array of each sector`s 95% flux scale factor.
---
> C        SC95    - array of each sector's 95% flux scale factor.
2277c5159
< C       SC50    - array of each sector`s 50% flux scale factor.
---
> C        SC50    - array of each sector's 50% flux scale factor.
2279c5161
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C        SCSIG   - array of each sector's std dev flux scale factor.
2281c5163
< C       XTAIL   - satellite`s X-coordinate in geotail system (Re).
---
> C        XTAIL   - satellite's X-coordinate in geotail system (Re).
2283c5165
< C       YTAIL   - satellite`s Y-coordinate in geotail system (Re).
---
> C        YTAIL   - satellite's Y-coordinate in geotail system (Re).
2285c5167
< C       ZTAIL   - satellite`s Z-coordinate in geotail system (Re).
---
> C        ZTAIL   - satellite's Z-coordinate in geotail system (Re).
2287c5169
< C       NUMDAT  - number of non-zero values in the database.
---
> C        NUMDAT  - number of non-zero values in the database.
2289,2290c5171,5172
< C       XFLUX   - array containing the X-coordinate of each data
< C                 cell`s center  (Re).
---
> C        XFLUX   - array containing the X-coordinate of each data
> C                  cell's center  (Re).
2292,2293c5174,5175
< C       YFLUX   - array containing the Y-coordinate of each data
< C                 cell`s center  (Re).
---
> C        YFLUX   - array containing the Y-coordinate of each data
> C                  cell's center  (Re).
2295,2296c5177,5178
< C       ZFLUX   - array containing the Z-coordinate of each data
< C                 cell`s center  (Re).
---
> C        ZFLUX   - array containing the Z-coordinate of each data
> C                  cell's center  (Re).
2298,2299c5180,5181
< C       FLUXBIN - array containing the average ion flux within
< C                 each cell  (ions/[cm^2-sec-sr-MeV]).
---
> C        FLUXBIN - array containing the average ion flux within
> C                  each cell  (ions/[cm^2-sec-sr-MeV]).
2301,2302c5183,5184
< C       NUMBIN  - array containing the number of non-zero values within
< C                 each cell.
---
> C        NUMBIN  - array containing the number of non-zero values within
> C                  each cell.
2304,2318c5186,5200
< C       SMOOTH1 - flag for control of database smoothing filter:
< C              SMOOTH1 = 0 if no data smoothing is used.
< C              SMOOTH1 = 1 if spike rejection and near neighbor flux.
< C              SMOOTH1 = 2 if spike rejection with range weighted
< C                           scaling of flux.
< C              SMOOTH1 = 3 if spike rejection with average flux.
< C              SMOOTH1 = 4 if spatial average of flux in volume
< C                           specified by RNGTOL.
< C              SMOOTH1 = 5 if spatial average of flux in volume
< C                           specified by RNGTOL, with the specified
< C                           number of high and low flux values inside
< C                           the volume dropped first.
< C              SMOOTH1 = 6 if spatial averaging of flux in volume
< C                           specified by RNGTOL, with percentile
< C                           threshold limits on flux values.
---
> C        SMOOTH1 - flag for control of database smoothing filter:
> C               SMOOTH1 = 0 if no data smoothing is used.
> C               SMOOTH1 = 1 if spike rejection and near neighbor flux.
> C               SMOOTH1 = 2 if spike rejection with range weighted
> C                            scaling of flux.
> C               SMOOTH1 = 3 if spike rejection with average flux.
> C               SMOOTH1 = 4 if spatial average of flux in volume
> C                            specified by RNGTOL.
> C               SMOOTH1 = 5 if spatial average of flux in volume
> C                            specified by RNGTOL, with the specified
> C                            number of high and low flux values inside
> C                            the volume dropped first.
> C               SMOOTH1 = 6 if spatial averaging of flux in volume
> C                            specified by RNGTOL, with percentile
> C                            threshold limits on flux values.
2320,2321c5202,5203
< C       NFLXGET - number of flux values to get for smoothing filter
< C                  (used if SMOOTH1 = 1,2, or 3)
---
> C       NFLXGET  - number of flux values to get for smoothing filter
> C                   (used if SMOOTH1 = 1,2, or 3)
2323,2324c5205,5206
< C       NDROPHI - number of high flux values to drop for smoothing
< C                  filter (used if SMOOTH1 = 1,2,3, or 5).
---
> C       NDROPHI  - number of high flux values to drop for smoothing
> C                   filter (used if SMOOTH1 = 1,2,3, or 5).
2326,2327c5208,5209
< C       NDROPLO - number of low flux values to drop for smoothing
< C                  filter (used if SMOOTH1 = 1,2,3, or 5).
---
> C       NDROPLO  - number of low flux values to drop for smoothing
> C                   filter (used if SMOOTH1 = 1,2,3, or 5).
2329,2332c5211,5214
< C       LOGFLG  - flag controlling how flux average is performed
< C                  (used if SMOOTH1 = 2,3,4,5, or 6).
< C              LOGFLG = 1 if log10 of flux values used.
< C              LOGFLG = 2 if linear flux values used.
---
> C       LOGFLG   - flag controlling how flux average is performed
> C                   (used if SMOOTH1 = 2,3,4,5, or 6).
> C               LOGFLG = 1 if log10 of flux values used.
> C               LOGFLG = 2 if linear flux values used.
2334,2336c5216,5218
< C       RNGTOL  - range tolerance from near-neigbor used in spatial
< C                  averaging of database (Re)
< C                  (used if SMOOTH1 = 4,5, or 6).
---
> C       RNGTOL   - range tolerance from near-neigbor used in spatial
> C                   averaging of database (Re)
> C                   (used if SMOOTH1 = 4,5, or 6).
2338,2339c5220,5221
< C       FPCHI   - upper percentile limit for spatial averaging of flux
< C                  (used if SMOOTH1 = 6).
---
> C       FPCHI    - upper percentile limit for spatial averaging of flux
> C                   (used if SMOOTH1 = 6).
2341,2342c5223,5230
< C       FPCLO   - lower percentile limit for spatial averaging of flux
< C                  (used if SMOOTH1 = 6).
---
> C       FPCLO    - lower percentile limit for spatial averaging of flux
> C                   (used if SMOOTH1 = 6).
> C       NSPHVOL  - number of volume elements stored in the
> C                  streamline mapping search volume.
> C       IOFFSET  - array of offset indices for X-direction.
> C       JOFFSET  - array of offset indices for Y-direction.
> C       KOFFSET  - array of offset indices for Z-direction.
> C       IMAPINDX - array of pointers for mapped database.
2359a5248,5254
>       INCLUDE 'MAXNUM.PAR'
>       INCLUDE 'BLEND.PAR'
> C
>       INCLUDE 'MAXNSPHVOL.PAR'
> C
>       INTEGER IOFFSET(MAXNSPHVOL),JOFFSET(MAXNSPHVOL)
>       INTEGER KOFFSET(MAXNSPHVOL),IMAPINDX(MAXKP,MAXNUM,MAXNUM,MAXNUM)
2366c5261,5262
<       INTEGER INDSECT(NUMSEC),NUMCELL(MAXKP)
---
>       REAL FLUX_Z(MAXKP),AVGNUM_Z(MAXKP),RNGCELL_Z(MAXKP)
>       INTEGER INDSECT(NUMSEC),NUMCELL(MAXKP),NUMCELL_Z(MAXKP)
2375c5271
< D     WRITE(*,*)' Entered NBRFLUX!'
---
> D     WRITE(*,*)' Entered NBRFLUX_MAP_Z!'
2408c5304
< C     sphere, which is needed because of GEOTAIL`s orbit.
---
> C     sphere, which is needed because of GEOTAIL's orbit.
2445c5341,5347
<       RNGCHK = 1.0
---
>       IF((SMOOTH1.EQ.4).OR.(SMOOTH1.EQ.5).OR.(SMOOTH1.EQ.6)) THEN
> C       Spatial averaging is used.
>         RNGCHK = RNGTOL
>       ELSE
> C       There is no data smoothing used.
>         RNGCHK = 1.0
>       END IF
2446a5349
> C     Find the index for the current Kp value.
2447a5351,5370
>         IF((XKP.LE.FLOAT(I)).AND.(XKP.GE.FLOAT(I-1))) THEN
>           IKP = I
>           FLUX(IKP) = 0.
>           AVGNUM(IKP) = 0.
>           RNGCELL(IKP) = 0.
>           NUMCELL(IKP) = 0
>           FLUX_Z(IKP) = 0.
>           AVGNUM_Z(IKP) = 0.
>           RNGCELL_Z(IKP) = 0.
>           NUMCELL_Z(IKP) = 0
>           GO TO 1000
>         END IF
>       END DO
> 1000  CONTINUE
> C
> D     WRITE(*,*)' XKP,IKP = ',XKP,IKP
> D     PAUSE 'PAUSED!'
> C
> C
>       DO IKP = 3,7
2451,2453c5374,5383
<           CALL FLXDAT1(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $      FLUXBIN,NUMBIN,RNGCHK,FLUX(I),AVGNUM(I),RNGCELL(I),
<      $      NUMCELL(I))
---
> C
>           CALL FLXDAT1_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $      IMAPINDX,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP))
> C
>           CALL FLXDAT1_MAP_Z(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,
>      $      IMAPINDX,FLUX_Z(IKP),AVGNUM_Z(IKP),RNGCELL_Z(IKP),
>      $      NUMCELL_Z(IKP))
> C
2456,2458c5386,5396
<           CALL FLXDAT2(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $      FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
<      $      LOGFLG,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I))
---
> C
>           CALL FLXDAT2_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $      LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX(IKP),
>      $      AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP))
> C
>           CALL FLXDAT2_MAP_Z(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,SMOOTH1,NFLXGET,NDROPHI,NDROPLO,
>      $      LOGFLG,NSPHVOL,IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX_Z(IKP),
>      $      AVGNUM_Z(IKP),RNGCELL_Z(IKP),NUMCELL_Z(IKP))
> C
2463,2465c5401,5410
<           CALL FLXDAT3(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $      FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,FLUX(I),
<      $      AVGNUM(I),RNGCELL(I),NUMCELL(I))
---
> C
>           CALL FLXDAT3_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,NSPHVOL,
>      $      IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX(IKP),AVGNUM(IKP),
>      $      RNGCELL(IKP),NUMCELL(IKP))
> C
>           CALL FLXDAT3_MAP_Z(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,NDROPHI,NDROPLO,LOGFLG,NSPHVOL,
>      $      IOFFSET,JOFFSET,KOFFSET,IMAPINDX,FLUX_Z(IKP),AVGNUM_Z(IKP),
>      $      RNGCELL_Z(IKP),NUMCELL_Z(IKP))
2470,2472c5415,5424
<           CALL FLXDAT4(I,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,ZFLUX,
<      $      FLUXBIN,NUMBIN,RNGCHK,LOGFLG,FPCHI,FPCLO,FLUX(I),AVGNUM(I),
<      $      RNGCELL(I),NUMCELL(I))
---
> C
>           CALL FLXDAT4_MAP(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,LOGFLG,NSPHVOL,IOFFSET,JOFFSET,
>      $      KOFFSET,IMAPINDX,FPCHI,FPCLO,FLUX(IKP),AVGNUM(IKP),
>      $      RNGCELL(IKP),NUMCELL(IKP))
> C
>           CALL FLXDAT4_MAP_Z(IKP,XTAIL,YTAIL,ZTAIL,NUMDAT,XFLUX,YFLUX,
>      $      ZFLUX,FLUXBIN,NUMBIN,RNGCHK,LOGFLG,NSPHVOL,IOFFSET,JOFFSET,
>      $      KOFFSET,IMAPINDX,FPCHI,FPCLO,FLUX_Z(IKP),AVGNUM_Z(IKP),
>      $      RNGCELL_Z(IKP),NUMCELL_Z(IKP))
2474,2476d5425
< D       WRITE(*,*)' After FLUXDAT!'
< D       WRITE(*,*)' I,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I) = ',
< D    $              I,FLUX(I),AVGNUM(I),RNGCELL(I),NUMCELL(I)
2477a5427,5435
> D     WRITE(*,*)' After FLUXDAT!'
> D     DO IKP = 3,7
> D      WRITE(*,*)' IKP,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),',
> D    $           'NUMCELL(IKP) = ',
> D    $     IKP,FLUX(IKP),AVGNUM(IKP),RNGCELL(IKP),NUMCELL(IKP)
> D      WRITE(*,*)' IKP,FLUX_Z(IKP),AVGNUM_Z(IKP),RNGCELL_Z(IKP),',
> D    $           'NUMCELL_Z(IKP) = ',
> D    $     IKP,FLUX_Z(IKP),AVGNUM_Z(IKP),RNGCELL_Z(IKP),NUMCELL_Z(IKP)
> D     END DO
2480c5438
< C     database`s Kp intervals.
---
> C     database's Kp intervals.
2482,2483c5440,5447
<       RNG1 = RNGMIN1(MAXKP,RNGCELL)
< D     WRITE(*,*)' After RNGMIN!'
---
>       RNG1 = 1.E+20
>       DO IKP = 3,7
>         IF(RNG1.GE.RNGCELL(IKP)) RNG1 = RNGCELL(IKP)
>       END DO
>       DELTARNG = 0.2
>       RNG2 = RNG1 + DELTARNG
> D     WRITE(*,*)' After RNGMIN!  DELTARNG,RNG1,RNG2 = ',
> D    $                           DELTARNG,RNG1,RNG2
2488c5452
< C     value at the spacecraft`s location by the distance weighted sum
---
> C     value at the spacecraft's location by the distance weighted sum
2491,2497c5455,5456
<       IF((SMOOTH1.EQ.4).OR.(SMOOTH1.EQ.5).OR.(SMOOTH1.EQ.6)) THEN
< C       Spatial averaging is used.
<         RNGCHK = RNGTOL
<       ELSE
< C       There is no data smoothing used.
<         RNGCHK = 1.0
<       END IF
---
> C     ***** Calculate the flux values without Z-binning *****
> C     *****        of near-neighbor flux values.        *****
2499,2504c5458,5462
<       TOTNUM = 0.
<       FLUXMN = 0.
<       FLUX95 = 0.
<       FLUX50 = 0.
<       FLUXSD = 0.
<       RNG2 = RNG1 + RNGCHK
---
>       TOTNUM1 = 0.
>       FLUXMN1 = 0.
>       FLUX951 = 0.
>       FLUX501 = 0.
>       FLUXSD1 = 0.
2507,2517c5465,5477
<       DO I = 1,MAXKP
<         IF(RNGCELL(I).LE.RNG2) THEN
<           ANNDIST = ANNDIST + RNGCELL(I)*AVGNUM(I)
<           FLUXMN = FLUXMN + FLUX(I)*AVGNUM(I)*WTMEAN(I)
< D         WRITE(*,*)' I,RNGCELL(I),RNG2,FLUXMN,AVGNUM(I),WTMEAN(I) = ',
< D    $                I,RNGCELL(I),RNG2,FLUXMN,AVGNUM(I),WTMEAN(I)
<           FLUX95 = FLUX95 + FLUX(I)*AVGNUM(I)*WT95(I)
<           FLUX50 = FLUX50 + FLUX(I)*AVGNUM(I)*WT50(I)
<           FLUXSD = FLUXSD + FLUX(I)*AVGNUM(I)*WTSIG(I)
<           TOTNUM = TOTNUM + AVGNUM(I)
< D         WRITE(*,*)' I,TOTNUM = ',I,TOTNUM
---
>       DO IKP = 3,7
>         IF(RNGCELL(IKP).LE.RNG2) THEN
>           ANNDIST = ANNDIST + RNGCELL(IKP)*AVGNUM(IKP)
>           FLUXMN1 = FLUXMN1 + FLUX(IKP)*AVGNUM(IKP)*WTMEAN(IKP)
> D         WRITE(*,*)' XKP,XTAIL,YTAIL,ZTAIL = ',XKP,XTAIL,YTAIL,ZTAIL
> D         WRITE(*,*)' IKP,FLUX(IKP),RNGCELL(IKP),RNG2 = ',
> D    $                IKP,FLUX(IKP),RNGCELL(IKP),RNG2
> D         WRITE(*,*)' FLUXMN1,AVGNUM(IKP),WTMEAN(IKP) = ',
> D    $                FLUXMN1,AVGNUM(IKP),WTMEAN(IKP)
>           FLUX951 = FLUX951 + FLUX(IKP)*AVGNUM(IKP)*WT95(IKP)
>           FLUX501 = FLUX501 + FLUX(IKP)*AVGNUM(IKP)*WT50(IKP)
>           FLUXSD1 = FLUXSD1 + FLUX(IKP)*AVGNUM(IKP)*WTSIG(IKP)
>           TOTNUM1 = TOTNUM1 + AVGNUM(IKP)
2521c5481,5482
<       ANNDIST = ANNDIST/TOTNUM
---
>       IF(TOTNUM1.LT.1.0) TOTNUM1 = 1.0
>       ANNDIST = ANNDIST/TOTNUM1
2523,2526c5484,5554
<       FLUXMN = FLUXMN/TOTNUM
<       FLUX95 = FLUX95/TOTNUM
<       FLUX50 = FLUX50/TOTNUM
<       FLUXSD = FLUXSD/TOTNUM
---
>       FLUXMN1 = FLUXMN1/TOTNUM1
> D     WRITE(*,*)' IKP,TOTNUM1,FLUXMN1 = ',IKP,TOTNUM1,FLUXMN1
> D     WRITE(*,*)
>       FLUX951 = FLUX951/TOTNUM1
>       FLUX501 = FLUX501/TOTNUM1
>       FLUXSD1 = FLUXSD1/TOTNUM1
> C
> C     ***** Calculate the flux values with Z-binning    *****
> C     *****        of near-neighbor flux values.        *****
> C
>       TOTNUM2 = 0.
>       FLUXMN2 = 0.
>       FLUX952 = 0.
>       FLUX502 = 0.
>       FLUXSD2 = 0.
> C
>       ANNDIST = 0.
>       DO IKP = 3,7
>         IF(RNGCELL(IKP).LE.RNG2) THEN
>           ANNDIST = ANNDIST + RNGCELL_Z(IKP)*AVGNUM_Z(IKP)
>           FLUXMN2 = FLUXMN2 + FLUX_Z(IKP)*AVGNUM_Z(IKP)*WTMEAN(IKP)
> D         WRITE(*,*)' XKP,XTAIL,YTAIL,ZTAIL = ',XKP,XTAIL,YTAIL,ZTAIL
> D         WRITE(*,*)' IKP,FLUX_Z(IKP),RNGCELL_Z(IKP),RNG2 = ',
> D    $                IKP,FLUX_Z(IKP),RNGCELL_Z(IKP),RNG2
> D         WRITE(*,*)' FLUXMN2,AVGNUM_Z(IKP),WTMEAN(IKP) = ',
> D    $                FLUXMN2,AVGNUM_Z(IKP),WTMEAN(IKP)
>           FLUX952 = FLUX952 + FLUX_Z(IKP)*AVGNUM_Z(IKP)*WT95(IKP)
>           FLUX502 = FLUX502 + FLUX_Z(IKP)*AVGNUM_Z(IKP)*WT50(IKP)
>           FLUXSD2 = FLUXSD2 + FLUX_Z(IKP)*AVGNUM_Z(IKP)*WTSIG(IKP)
>           TOTNUM2 = TOTNUM2 + AVGNUM_Z(IKP)
>         END IF
>       END DO
> C
>       IF(TOTNUM2.LT.1.0) TOTNUM2 = 1.0
>       ANNDIST = ANNDIST/TOTNUM2
> C
>       FLUXMN2 = FLUXMN2/TOTNUM2
> D     WRITE(*,*)' IKP,TOTNUM2,FLUXMN2 = ',IKP,TOTNUM2,FLUXMN2
> D     WRITE(*,*)
>       FLUX952 = FLUX952/TOTNUM2
>       FLUX502 = FLUX502/TOTNUM2
>       FLUXSD2 = FLUXSD2/TOTNUM2
> C
> C     ***** Perform the blending of the flux values from *****
> C     ***** the two near-neighbor algorithms.            *****
> C
> C     Find the relative weighting of the two flux values.
>       IF(XTAIL.GE.BLENDX1) THEN
> C       Do not use z-layers to find the near-neighbor flux.
>         BLEND1 = 1.0
>         BLEND2 = 0.0
>       ELSE IF(XTAIL.LE.BLENDX2) THEN
> C       Only use z-layers to find the near-neighbor flux.
>         BLEND1 = 0.0
>         BLEND2 = 1.0
>       ELSE
> C       The spacecraft is in the transition (blending) region.
>         BLEND1 = YINT(BLENDX1,1.0,BLENDX2,0.0,XTAIL,1)
>         IF(BLEND1.GE.1.0) BLEND1 = 1.0
>         IF(BLEND1.LE.0.0) BLEND1 = 0.0
>         BLEND2 = 1.0 - BLEND1
>       END IF
> C
> D     WRITE(*,*)' BLENDX1,BLENDX2,BLEND1,BLEND2 = ',
> D    $            BLENDX1,BLENDX2,BLEND1,BLEND2
> C
> C     Get the final flux values.
>       FLUXMN = FLUXMN1*BLEND1 + FLUXMN2*BLEND2
>       FLUX95 = FLUX951*BLEND1 + FLUX952*BLEND2
>       FLUX50 = FLUX501*BLEND1 + FLUX502*BLEND2
>       FLUXSD = FLUXSD1*BLEND1 + FLUXSD2*BLEND2
2540,2541c5568,5569
< C       XTAIL   - satellite`s X-coordinate in geotail system (Re).
< C       YTAIL   - satellite`s Y-coordinate in geotail system (Re).
---
> C       XTAIL   - satellite's X-coordinate in geotail system (Re).
> C       YTAIL   - satellite's Y-coordinate in geotail system (Re).
2543,2544c5571,5572
< C       SECTX   - array of each sector center`s x coordinate.
< C       SECTY   - array of each sector center`s y coordinate.
---
> C       SECTX   - array of each sector center's x coordinate.
> C       SECTY   - array of each sector center's y coordinate.
2634,2639c5662,5667
< C       SECTX   - array of each sector center`s x coordinate.
< C       SECTY   - array of each sector center`s y coordinate.
< C       SCMEAN  - array of each sector`s mean flux scale factor.
< C       SC95    - array of each sector`s 95% flux scale factor.
< C       SC50    - array of each sector`s 50% flux scale factor.
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C       SECTX   - array of each sector center's x coordinate.
> C       SECTY   - array of each sector center's y coordinate.
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C       SC95    - array of each sector's 95% flux scale factor.
> C       SC50    - array of each sector's 50% flux scale factor.
> C       SCSIG   - array of each sector's std dev flux scale factor.
2692,2697c5720,5725
< C       SECTX   - array of each sector center`s x coordinate.
< C       SECTY   - array of each sector center`s y coordinate.
< C       SCMEAN  - array of each sector`s mean flux scale factor.
< C       SC95    - array of each sector`s 95% flux scale factor.
< C       SC50    - array of each sector`s 50% flux scale factor.
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C       SECTX   - array of each sector center's x coordinate.
> C       SECTY   - array of each sector center's y coordinate.
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C       SC95    - array of each sector's 95% flux scale factor.
> C       SC50    - array of each sector's 50% flux scale factor.
> C       SCSIG   - array of each sector's std dev flux scale factor.
2753,2758c5781,5786
< C       SECTX   - array of each sector center`s x coordinate.
< C       SECTY   - array of each sector center`s y coordinate.
< C       SCMEAN  - array of each sector`s mean flux scale factor.
< C       SC95    - array of each sector`s 95% flux scale factor.
< C       SC50    - array of each sector`s 50% flux scale factor.
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C       SECTX   - array of each sector center's x coordinate.
> C       SECTY   - array of each sector center's y coordinate.
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C       SC95    - array of each sector's 95% flux scale factor.
> C       SC50    - array of each sector's 50% flux scale factor.
> C       SCSIG   - array of each sector's std dev flux scale factor.
2839,2840c5867,5868
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
2846c5874
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
2928,2929c5956,5957
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
2935c5963
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3017,3018c6045,6046
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3024c6052
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3106,3107c6134,6135
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3113c6141
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3195,3196c6223,6224
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3202c6230
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3284,3285c6312,6313
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3291c6319
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3373,3374c6401,6402
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3380c6408
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3462,3463c6490,6491
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3469c6497
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3551,3552c6579,6580
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3554c6582
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3634,3635c6662,6663
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3637c6665
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3712,3713c6740,6741
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3715c6743
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3790,3791c6818,6819
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3793c6821
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3868,3869c6896,6897
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3871c6899
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
3951,3952c6979,6980
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
3954c6982
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
4029,4030c7057,7058
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
4032c7060
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
4073c7101
<         SCMEA = -1.E-11
---
>         SCMEAN = -1.E-11
4111,4112c7139,7140
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
4114c7142
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
4189,4190c7217,7218
< C       XCEN    - sector center`s x-coordinate (Re).
< C       YCEN    - sector center`s x-coordinate (Re).
---
> C       XCEN    - sector center's x-coordinate (Re).
> C       YCEN    - sector center's x-coordinate (Re).
4192c7220
< C     Set up this sector`s limits.
---
> C     Set up this sector's limits.
4345,4346c7373,7381
<         DYPRES = 4.0
<         ABANG = 0.0
---
>         DYPRES1 = 1.0
>         ABANG1 = 4.0
>         VX1 = -400.
>         DYPRES2 = 4.0
>         ABANG2 = 0.0
>         VX2 = -500.
> C
>         DYPRES = YINT(4.,DYPRES1,6.,DYPRES2,XKP,1)
>         ABANG  = YINT(4.,ABANG1,6.,ABANG2,XKP,1)
4348c7383
<         VX = -500.
---
>         VX     = YINT(4.,VX1,6.,VX2,XKP,1)
4350c7385,7388
<         DYPRES = 10.0
---
>         DYPRES1 = 4.0
>         DYPRES2 = 10.0
> C
>         DYPRES = YINT(6.,DYPRES1,9.,DYPRES2,XKP,1)
4434a7473,7621
>       SUBROUTINE SORTRNGINDEX(n,arr,brr,crr,drr)
> C
> C     ***  Based on SORT2 taken from "Numerical Recipes"  ***
> C     Sorts an array arr(1:n) into ascending order using Quicksort,
> C     while making the corresponding rearrangement of the integer
> C     index arrays: brr(1:n), crr(1:n), drr(1:n).
> C
>       INTEGER n,M,NSTACK
>       REAL arr(n)
>       INTEGER brr(n),crr(n),drr(n),ib,ic,id
>       PARAMETER (M=7,NSTACK=50)
>       INTEGER i,ir,j,jstack,k,l,istack(NSTACK)
>       REAL a,temp
>       jstack=0
>       l=1
>       ir=n
> 1     if(ir-l.lt.M)then   ! Insertion sort when subarray small enough.
>         do j=l+1,ir
>           a=arr(j)
>           ib=brr(j)
>           ic=crr(j)
>           id=drr(j)
>           do i=j-1,l,-1
>             if(arr(i).le.a)goto 2
>             arr(i+1)=arr(i)
>             brr(i+1)=brr(i)
>             crr(i+1)=crr(i)
>             drr(i+1)=drr(i)
>           enddo
>           i=l-1
> 2         arr(i+1)=a
>           brr(i+1)=ib
>           crr(i+1)=ic
>           drr(i+1)=id
>         enddo
>         if(jstack.eq.0)return
>         ir=istack(jstack) ! Pop stack and begin a new round of partitioning.
>         l=istack(jstack-1)
>         jstack=jstack-2
>       else
>         k=(l+ir)/2        ! Choose median of left, center and right elements
> C                         ! as partitioning element a. Also rearrange so 
> C                         ! that a(l) <= a(l+1) <= a(ir).
>         temp=arr(k)
>         arr(k)=arr(l+1)
>         arr(l+1)=temp
>         itemp=brr(k)
>         brr(k)=brr(l+1)
>         brr(l+1)=itemp
>         itemp=crr(k)
>         crr(k)=crr(l+1)
>         crr(l+1)=itemp
>         itemp=drr(k)
>         drr(k)=drr(l+1)
>         drr(l+1)=itemp
>         if(arr(l).gt.arr(ir))then
>           temp=arr(l)
>           arr(l)=arr(ir)
>           arr(ir)=temp
>           itemp=brr(l)
>           brr(l)=brr(ir)
>           brr(ir)=itemp
>           itemp=crr(l)
>           crr(l)=crr(ir)
>           crr(ir)=itemp
>           itemp=drr(l)
>           drr(l)=drr(ir)
>           drr(ir)=itemp
>         endif
>         if(arr(l+1).gt.arr(ir))then
>           temp=arr(l+1)
>           arr(l+1)=arr(ir)
>           arr(ir)=temp
>           itemp=brr(l+1)
>           brr(l+1)=brr(ir)
>           brr(ir)=itemp
>           itemp=crr(l+1)
>           crr(l+1)=crr(ir)
>           crr(ir)=itemp
>           itemp=drr(l+1)
>           drr(l+1)=drr(ir)
>           drr(ir)=itemp
>         endif
>         if(arr(l).gt.arr(l+1))then
>           temp=arr(l)
>           arr(l)=arr(l+1)
>           arr(l+1)=temp
>           itemp=brr(l)
>           brr(l)=brr(l+1)
>           brr(l+1)=itemp
>           itemp=crr(l)
>           crr(l)=crr(l+1)
>           crr(l+1)=itemp
>           itemp=drr(l)
>           drr(l)=drr(l+1)
>           drr(l+1)=itemp
>         endif
>         i=l+1            ! Initialize pointers for partitioning.
>         j=ir
>         a=arr(l+1)       ! Partitioning element.
>         ib=brr(l+1)
>         ic=crr(l+1)
>         id=drr(l+1)
> 3       continue         ! Beginning of innermost loop.
>           i=i+1          ! Scan up to find element > a.
>         if(arr(i).lt.a)goto 3
> 4       continue
>           j=j-1          ! Scan down to find element < a.
>         if(arr(j).gt.a)goto 4
>         if(j.lt.i)goto 5 ! Pointers crossed. Exit with partitioning complete.
>         temp=arr(i)      ! Exchange elements of both arrays.
>         arr(i)=arr(j)
>         arr(j)=temp
>         itemp=brr(i)
>         brr(i)=brr(j)
>         brr(j)=itemp
>         itemp=crr(i)
>         crr(i)=crr(j)
>         crr(j)=itemp
>         itemp=drr(i)
>         drr(i)=drr(j)
>         drr(j)=itemp
>         goto 3           ! End of innermost loop.
> 5       arr(l+1)=arr(j)  ! Insert partitioning element in both arrays.
>         arr(j)=a
>         brr(l+1)=brr(j)
>         brr(j)=ib
>         crr(l+1)=crr(j)
>         crr(j)=ic
>         drr(l+1)=drr(j)
>         drr(j)=id
>         jstack=jstack+2
> C                        ! Push pointers to larger subarray on stack,
> C                        ! process smaller subarray immediately.
>         if(jstack.gt.NSTACK)pause 'NSTACK too small in sort2'
>         if(ir-i+1.ge.j-l)then
>           istack(jstack)=ir
>           istack(jstack-1)=i
>           ir=j-1
>         else
>           istack(jstack)=j-1
>           istack(jstack-1)=l
>           l=i
>         endif
>       endif
>       goto 1
>       END
> C
> C
4693c7880
< C     (1) Multiply the closest sector`s Kp scaling factors by the
---
> C     (1) Multiply the closest sector's Kp scaling factors by the
4695c7882
< C     (2) Multiply the  2nd closest sector`s Kp scaling factors by the
---
> C     (2) Multiply the  2nd closest sector's Kp scaling factors by the
4697c7884
< C     (3) Repeat this process until you multiply the farthest sector`s
---
> C     (3) Repeat this process until you multiply the farthest sector's
4704,4705c7891,7892
< C       XTAIL   - satellite`s X-coordinate in geotail system (Re).
< C       YTAIL   - satellite`s Y-coordinate in geotail system (Re).
---
> C       XTAIL   - satellite's X-coordinate in geotail system (Re).
> C       YTAIL   - satellite's Y-coordinate in geotail system (Re).
4712,4715c7899,7902
< C       SCMEAN  - array of each sector`s mean flux scale factor.
< C       SC95    - array of each sector`s 95% flux scale factor.
< C       SC50    - array of each sector`s 50% flux scale factor.
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C       SC95    - array of each sector's 95% flux scale factor.
> C       SC50    - array of each sector's 50% flux scale factor.
> C       SCSIG   - array of each sector's std dev flux scale factor.
4810,4813c7997,8000
< C       SCMEAN  - array of each sector`s mean flux scale factor.
< C       SC95    - array of each sector`s 95% flux scale factor.
< C       SC50    - array of each sector`s 50% flux scale factor.
< C       SCSIG   - array of each sector`s std dev flux scale factor.
---
> C       SCMEAN  - array of each sector's mean flux scale factor.
> C       SC95    - array of each sector's 95% flux scale factor.
> C       SC50    - array of each sector's 50% flux scale factor.
> C       SCSIG   - array of each sector's std dev flux scale factor.
4913a8101,8168
>       SUBROUTINE ZBINNER(XGSM,ZGSM,ZCKLO,ZCKHI)
> C
> C     This routine determines the z-layer of the magnetosphere used to
> C     find the spacecraft's near-neighbor flux.
> C
> C     INPUTS:
> C       XGSM    - satellite's X-coordinate (Re).
> C       ZGSM    - satellite's Z-coordinate (Re).
> C
> C     OUTPUTS:
> C       ZCKLO   - lower z-value used to check for near-neighbor flux (Re).
> C       ZCKHI   - upper z-value used to check for near-neighbor flux (Re).
> C
>       IF(XGSM.GE.0.) THEN
> C       Do not use Z-layers on the dayside of the magnetosphere.
>         ZCKLO = -7.
>         ZCKHI = +100.
>       ELSE
> C       Use the nearest neighbor flux only inside a range of Z-values.
>         IF(ZGSM.LE.-6.) THEN
> C         Use the nearest neighbor in the -7 < Z < -6. range.
>           ZCKLO = -7.
>           ZCKHI = -6.
>         ELSE IF((ZGSM.GT.-6.).AND.(ZGSM.LE.-5.)) THEN
> C         Use the nearest neighbor in the -6 < Z < -5. range.
>           ZCKLO = -6.
>           ZCKHI = -5.
>         ELSE IF((ZGSM.GT.-5.).AND.(ZGSM.LE.+4.)) THEN
> C         Use the nearest neighbor in the -5 < Z < +4. range.
>           ZCKLO = -5.
>           ZCKHI = +4.
>         ELSE IF((ZGSM.GT.+4.).AND.(ZGSM.LE.+5.)) THEN
> C         Use the nearest neighbor in the +4 < Z < +5. range.
>           ZCKLO = +4.
>           ZCKHI = +5.
>         ELSE IF((ZGSM.GT.+5.).AND.(ZGSM.LE.+6.)) THEN
> C         Use the nearest neighbor in the +5 < Z < +6. range.
>           ZCKLO = +5.
>           ZCKHI = +6.
>         ELSE IF((ZGSM.GT.+6.).AND.(ZGSM.LE.+7.)) THEN
> C         Use the nearest neighbor in the +6 < Z < +7. range.
>           ZCKLO = +6.
>           ZCKHI = +7.
>         ELSE IF((ZGSM.GT.+7.).AND.(ZGSM.LE.+8.)) THEN
> C         Use the nearest neighbor in the +7 < Z < +8. range.
>           ZCKLO = +7.
>           ZCKHI = +8.
>         ELSE IF((ZGSM.GT.+8.).AND.(ZGSM.LE.+9.)) THEN
> C         Use the nearest neighbor in the +8 < Z < +9. range.
>           ZCKLO = +8.
>           ZCKHI = +9.
>         ELSE IF((ZGSM.GT.+9.).AND.(ZGSM.LE.+10.)) THEN
> C         Use the nearest neighbor in the +9 < Z < +10. range.
>           ZCKLO = +9.
>           ZCKHI = +10.
>         ELSE IF(ZGSM.GT.+10.) THEN
> C         Use the nearest neighbor in the +10 < Z < +11. range.
>           ZCKLO = +10.
>           ZCKHI = +11.
>         END IF
>       END IF
> C
> D     WRITE(*,*)' ZCKLO,ZCKHI = ',ZCKLO,ZCKHI
> C
>       RETURN
>       END
> C
> C
